<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultrahuman Device Dashboard</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background-color: #fafafa; 
            color: #333; 
            line-height: 1.6;
        } 
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background-color: #fff; 
            border-radius: 12px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.08); 
            overflow: hidden;
        } 
        .section { 
            padding: 32px; 
            border-bottom: 1px solid #eee; 
        } 
        .section:last-child { border-bottom: none; }
        h1 { 
            text-align: center; 
            color: #1a1a1a; 
            margin: 0 0 8px 0; 
            font-size: 2.25rem; 
            font-weight: 700; 
            letter-spacing: -0.025em;
        } 
        h2 { 
            margin: 0 0 24px 0; 
            color: #1a1a1a; 
            font-size: 1.5rem; 
            font-weight: 600; 
            border-bottom: 2px solid #1a1a1a; 
            padding-bottom: 8px;
        } 
        h3 { 
            color: #1a1a1a; 
            margin: 0 0 12px 0; 
            font-size: 1.125rem; 
            font-weight: 600;
        } 
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin: 24px 0; 
            background: #fff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06);
        } 
        th, td { 
            padding: 12px 16px; 
            text-align: left; 
            border-bottom: 1px solid #eee; 
            word-break: break-all; 
        } 
        th { 
            background-color: #f8f9fa; 
            font-weight: 600; 
            color: #1a1a1a;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        } 
        tr:hover { background-color: #f8f9fa; } 
        .form-group { 
            margin-bottom: 24px; 
        } 
        label { 
            display: block; 
            margin-bottom: 8px; 
            font-weight: 500; 
            color: #1a1a1a; 
            font-size: 0.875rem;
        } 
        input[type="text"], input[type="email"], input[type="date"], select { 
            width: 100%; 
            padding: 12px 16px; 
            border: 1px solid #d1d5db; 
            border-radius: 6px; 
            font-size: 0.875rem;
            transition: border-color 0.15s ease;
            background: #fff;
        } 
        input[type="text"]:focus, input[type="email"]:focus, input[type="date"]:focus, select:focus { 
            outline: none; 
            border-color: #1a1a1a; 
            box-shadow: 0 0 0 3px rgba(26, 26, 26, 0.1);
        }
        .radio-group {
            display: flex;
            gap: 24px;
            margin: 16px 0;
        }
        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .radio-option input[type="radio"] {
            width: auto;
            margin: 0;
        }
        .radio-option label {
            margin: 0;
            cursor: pointer;
            font-weight: 500;
            color: #6b7280;
        }
        .radio-option input[type="radio"]:checked + label {
            color: #1a1a1a;
        }
        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }
        button { 
            padding: 12px 24px; 
            background-color: #1a1a1a; 
            color: white; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 0.875rem; 
            font-weight: 500;
            transition: all 0.15s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        } 
        button:hover { 
            background-color: #374151; 
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        } 
        button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button.secondary { 
            background-color: #f3f4f6; 
            color: #374151; 
            border: 1px solid #d1d5db;
        } 
        button.secondary:hover { 
            background-color: #e5e7eb; 
            color: #1f2937;
        } 
        button.danger { 
            background-color: #ef4444; 
        } 
        button.danger:hover { 
            background-color: #dc2626; 
        } 
        .error { 
            color: #ef4444; 
            margin-top: 12px; 
            font-size: 0.875rem; 
            font-weight: 500;
            padding: 8px 12px;
            background: #fef2f2;
            border-radius: 6px;
            border-left: 4px solid #ef4444;
        } 
        .success { 
            color: #10b981; 
            margin-top: 12px; 
            font-size: 0.875rem; 
            font-weight: 500;
            padding: 8px 12px;
            background: #f0fdf4;
            border-radius: 6px;
            border-left: 4px solid #10b981;
        } 
        .metrics-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); 
            gap: 20px; 
            margin-top: 24px;
        } 
        .metric-card { 
            border: 1px solid #e5e7eb; 
            padding: 24px; 
            border-radius: 12px; 
            background-color: #fff; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.04); 
            max-height: 500px; 
            overflow-y: auto;
            transition: box-shadow 0.15s ease;
        } 
        .metric-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .metric-card h3 { 
            margin: 0 0 16px 0; 
            font-size: 1rem; 
            color: #1a1a1a; 
            border-bottom: 1px solid #e5e7eb; 
            padding-bottom: 8px; 
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.025em;
            font-size: 0.875rem;
        } 
        .metric-value { 
            font-size: 2rem; 
            font-weight: 700; 
            margin-bottom: 8px; 
            color: #1a1a1a; 
            line-height: 1;
        } 
        .metric-unit { 
            font-size: 0.875rem; 
            color: #6b7280; 
            margin-left: 8px; 
            font-weight: 500;
        } 
        .metric-details { 
            font-size: 0.875rem; 
            color: #6b7280; 
            margin: 8px 0;
        } 
        canvas { 
            max-width: 100%; 
            height: 250px !important; 
            margin-top: 16px; 
            display: block; 
            border-radius: 6px;
        }
        .chart-container { 
            height: 250px; 
            position: relative; 
            margin-top: 16px; 
        } 
        #loading-indicator { 
            text-align: center; 
            padding: 24px; 
            font-size: 0.875rem; 
            color: #6b7280; 
            display: none;
            background: #f9fafb;
            border-radius: 6px;
            margin: 16px 0;
        } 
        .date-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Ultrahuman Ring Device Dashboard</h1>

        <!-- User Management Section -->
        <div class="section" id="user-management">
            <h2>User Management</h2>
            <div id="user-list-section">
                <h3>Existing Users</h3>
                <table id="user-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Email</th>
                            <th>API Key (Partial)</th>
                            <th>Access Code</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- User rows will be populated by JavaScript -->
                    </tbody>
                </table>
                <button id="show-add-user-form">Add New User</button>
                <div id="user-list-message" class="success"></div>
            </div>

            <div id="user-form-section" style="display: none;">
                <h3 id="user-form-title">Add New User</h3>
                <form id="user-form">
                    <input type="hidden" id="user-id">
                    <div class="form-group">
                        <label for="email">Email:</label>
                        <input type="email" id="email" required>
                    </div>
                    <div class="form-group">
                        <label for="api-key">API Key:</label>
                        <input type="text" id="api-key" required>
                    </div>
                    <div class="form-group">
                        <label for="access-code">Access Code:</label>
                        <input type="text" id="access-code" required>
                    </div>
                    <div class="button-group">
                        <button type="submit" id="save-user-button">Save User</button>
                        <button type="button" id="cancel-edit-button" class="secondary">Cancel</button>
                    </div>
                </form>
                <div id="user-form-error" class="error"></div>
            </div>
        </div>

        <!-- Dashboard Section -->
        <div class="section" id="dashboard">
            <h2>Dashboard</h2>
            <div class="form-group">
                <label for="user-select">Select User:</label>
                <select id="user-select">
                    <option value="">-- Select a User --</option>
                    <!-- User options will be populated by JavaScript -->
                </select>
            </div>
            <div class="form-group">
                <label>Date Selection Mode</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="single-date-mode" name="date-mode" value="single" checked>
                        <label for="single-date-mode">Single Day</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="date-range-mode" name="date-mode" value="range">
                        <label for="date-range-mode">Date Range</label>
                    </div>
                </div>
            </div>
            <div class="form-group" id="single-date-group">
                <label for="date-select">Select Date</label>
                <input type="date" id="date-select">
            </div>
            <div class="form-group hidden" id="date-range-group">
                <label>Date Range</label>
                <div class="date-inputs">
                    <div>
                        <label for="start-date-select">Start Date</label>
                        <input type="date" id="start-date-select">
                    </div>
                    <div>
                        <label for="end-date-select">End Date</label>
                        <input type="date" id="end-date-select">
                    </div>
                </div>
            </div>
            <div class="button-group">
                <button id="fetch-data-button">Fetch Data</button>
                <button id="export-csv-button" class="secondary hidden">Export to CSV</button>
            </div>
            <div id="loading-indicator">Loading data...</div>
            <div id="dashboard-error" class="error"></div>

            <div id="metrics-display" class="metrics-grid" style="margin-top: 20px;">
                <!-- Metrics will be displayed here -->
            </div>
        </div>
    </div>

    <!-- Include Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <script>
        const userApiUrl = "/api/users"; // Relative path prefix
        const metricsApiUrlBase = "/api/metrics"; // Relative path prefix
        
        // Utility function for safe nested property access
        function safeGet(obj, path, defaultValue = null) {
            if (!obj || !path) return defaultValue;
            
            const keys = path.split('.');
            let result = obj;
            
            for (const key of keys) {
                if (result === null || result === undefined) {
                    return defaultValue;
                }
                result = result[key];
            }
            
            return result !== undefined ? result : defaultValue;
        }

        const userTableBody = document.getElementById("user-table").querySelector("tbody");
        const userSelect = document.getElementById("user-select");
        const userFormSection = document.getElementById("user-form-section");
        const userListSection = document.getElementById("user-list-section");
        const userForm = document.getElementById("user-form");
        const userFormTitle = document.getElementById("user-form-title");
        const userIdInput = document.getElementById("user-id");
        const emailInput = document.getElementById("email");
        const apiKeyInput = document.getElementById("api-key");
        const accessCodeInput = document.getElementById("access-code");
        const userFormError = document.getElementById("user-form-error");
        const userListMessage = document.getElementById("user-list-message");
        const showAddUserFormButton = document.getElementById("show-add-user-form");
        const cancelEditButton = document.getElementById("cancel-edit-button");

        const dateSelect = document.getElementById("date-select");
        const startDateSelect = document.getElementById("start-date-select");
        const endDateSelect = document.getElementById("end-date-select");
        const singleDateMode = document.getElementById("single-date-mode");
        const dateRangeMode = document.getElementById("date-range-mode");
        const singleDateGroup = document.getElementById("single-date-group");
        const dateRangeGroup = document.getElementById("date-range-group");
        const fetchDataButton = document.getElementById("fetch-data-button");
        const exportCsvButton = document.getElementById("export-csv-button");
        const metricsDisplay = document.getElementById("metrics-display");
        const dashboardError = document.getElementById("dashboard-error");
        const loadingIndicator = document.getElementById("loading-indicator");

        let currentChartInstances = {}; // To keep track of chart instances
        let currentMetricsData = null; // Store current data for CSV export

        // --- Utility Functions ---
        function displayError(element, message) {
            element.textContent = message;
            element.style.display = "block";
        }

        function clearError(element) {
            element.textContent = "";
            element.style.display = "none";
        }

        function displaySuccess(element, message) {
            element.textContent = message;
            element.style.display = "block";
            setTimeout(() => { element.style.display = "none"; }, 3000); // Hide after 3 seconds
        }

        // --- User Management Functions ---
        async function fetchUsers() {
            try {
                const response = await fetch(userApiUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const users = await response.json();
                populateUserTable(users);
                populateUserSelect(users);
            } catch (error) {
                console.error("Error fetching users:", error);
                displayError(userListMessage, `Error loading users: ${error.message}`);
            }
        }

        function populateUserTable(users) {
            userTableBody.innerHTML = ""; // Clear existing rows
            if (users.length === 0) {
                userTableBody.innerHTML = `<tr><td colspan="5">No users found.</td></tr>`;
                return;
            }
            users.forEach(user => {
                const row = userTableBody.insertRow();
                const apiKeyPartial = user.api_key ? `${user.api_key.substring(0, 4)}...${user.api_key.substring(user.api_key.length - 4)}` : "N/A";
                row.innerHTML = `
                    <td>${user.id}</td>
                    <td>${user.email}</td>
                    <td>${apiKeyPartial}</td>
                    <td>${user.access_code}</td>
                    <td>
                        <button class="secondary" onclick="editUser(${user.id}, '${user.email}', '${user.api_key}', '${user.access_code}')">Edit</button>
                        <button class="danger" onclick="deleteUser(${user.id})">Delete</button>
                    </td>
                `;
            });
        }

        function populateUserSelect(users) {
            userSelect.innerHTML = `<option value="">-- Select a User --</option>`; // Clear existing options
            users.forEach(user => {
                const option = document.createElement("option");
                option.value = user.id;
                option.textContent = `${user.email} (ID: ${user.id})`;
                userSelect.appendChild(option);
            });
        }

        function showUserForm(isEdit = false, id = null, email = "", apiKey = "", accessCode = "") {
            userForm.reset();
            userIdInput.value = id || "";
            emailInput.value = email;
            apiKeyInput.value = apiKey;
            accessCodeInput.value = accessCode;
            userFormTitle.textContent = isEdit ? "Edit User" : "Add New User";
            clearError(userFormError);
            userListSection.style.display = "none";
            userFormSection.style.display = "block";
        }

        function hideUserForm() {
            userFormSection.style.display = "none";
            userListSection.style.display = "block";
            userForm.reset();
            userIdInput.value = "";
            clearError(userFormError);
        }

        async function saveUser(event) {
            event.preventDefault();
            clearError(userFormError);

            const id = userIdInput.value;
            const userData = {
                email: emailInput.value,
                api_key: apiKeyInput.value,
                access_code: accessCodeInput.value
            };

            const method = id ? "PUT" : "POST";
            const url = id ? `${userApiUrl}/${id}` : userApiUrl;

            try {
                const response = await fetch(url, {
                    method: method,
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(userData),
                });

                let result;
                try {
                    result = await response.json();
                } catch (jsonError) {
                    // If JSON parsing fails, get the text response for better error reporting
                    const textResponse = await response.text();
                    throw new Error(`Server returned invalid JSON. Status: ${response.status}. Response: ${textResponse.substring(0, 200)}...`);
                }

                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                hideUserForm();
                fetchUsers(); // Refresh user list and dropdown
                displaySuccess(userListMessage, `User ${id ? "updated" : "added"} successfully!`);
            } catch (error) {
                console.error("Error saving user:", error);
                displayError(userFormError, `Error saving user: ${error.message}`);
            }
        }

        function editUser(id, email, apiKey, accessCode) {
            showUserForm(true, id, email, apiKey, accessCode);
        }

        async function deleteUser(id) {
            if (!confirm(`Are you sure you want to delete user ID ${id}?`)) {
                return;
            }

            try {
                const response = await fetch(`${userApiUrl}/${id}`, {
                    method: "DELETE",
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                fetchUsers(); // Refresh user list and dropdown
                displaySuccess(userListMessage, `User deleted successfully!`);
            } catch (error) {
                console.error("Error deleting user:", error);
                displayError(userListMessage, `Error deleting user: ${error.message}`);
            }
        }

        // --- Dashboard Functions ---
        function toggleDateMode() {
            if (singleDateMode.checked) {
                singleDateGroup.classList.remove("hidden");
                dateRangeGroup.classList.add("hidden");
            } else {
                singleDateGroup.classList.add("hidden");
                dateRangeGroup.classList.remove("hidden");
            }
        }

        function setDateToToday() {
            const today = new Date().toISOString().split("T")[0];
            dateSelect.value = today;
            startDateSelect.value = today;
            endDateSelect.value = today;
        }

        function validateDateRange() {
            if (dateRangeMode.checked) {
                const startDate = new Date(startDateSelect.value);
                const endDate = new Date(endDateSelect.value);
                if (startDate > endDate) {
                    displayError(dashboardError, "Start date must be before or equal to end date.");
                    return false;
                }
                const daysDiff = (endDate - startDate) / (1000 * 60 * 60 * 24);
                if (daysDiff > 30) {
                    displayError(dashboardError, "Date range cannot exceed 30 days.");
                    return false;
                }
            }
            return true;
        }

        async function fetchMetrics() {
            const userId = userSelect.value;
            
            clearError(dashboardError);
            metricsDisplay.innerHTML = ""; // Clear previous metrics
            destroyCharts(); // Destroy old charts before creating new ones
            exportCsvButton.classList.add("hidden");
            currentMetricsData = null;

            if (!userId) {
                displayError(dashboardError, "Please select a user.");
                return;
            }

            // Validate date inputs based on mode
            if (singleDateMode.checked) {
                if (!dateSelect.value) {
                    displayError(dashboardError, "Please select a date.");
                    return;
                }
            } else {
                if (!startDateSelect.value || !endDateSelect.value) {
                    displayError(dashboardError, "Please select both start and end dates.");
                    return;
                }
                if (!validateDateRange()) {
                    return;
                }
            }

            loadingIndicator.style.display = "block";
            fetchDataButton.disabled = true;

            try {
                let allMetricsData = [];
                let dateRange = [];

                if (singleDateMode.checked) {
                    // Single date mode
                    dateRange = [dateSelect.value];
                } else {
                    // Date range mode - generate array of dates
                    const startDate = new Date(startDateSelect.value);
                    const endDate = new Date(endDateSelect.value);
                    
                    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                        dateRange.push(d.toISOString().split('T')[0]);
                    }
                }

                // Fetch data for each date
                for (let i = 0; i < dateRange.length; i++) {
                    const date = dateRange[i];
                    loadingIndicator.textContent = `Loading data... (${i + 1}/${dateRange.length})`;
                    
                    const response = await fetch(`${metricsApiUrlBase}/${userId}?date=${date}`);
                    const result = await response.json();

                    if (!response.ok) {
                        console.warn(`Failed to fetch data for ${date}: ${result.error}`);
                        continue;
                    }

                    if (result.data && result.data.metric_data) {
                        // Add date info to each metric
                        const dateMetrics = result.data.metric_data.map(metric => ({
                            ...metric,
                            date: date
                        }));
                        allMetricsData.push(...dateMetrics);
                        
                        // Debug: Log a sample metric to understand structure
                        if (dateMetrics.length > 0) {
                            console.log(`Sample metric for ${date}:`, dateMetrics[0]);
                        }
                    }
                }

                if (allMetricsData.length > 0) {
                    currentMetricsData = allMetricsData;
                    if (singleDateMode.checked) {
                        displayMetrics(allMetricsData);
                    } else {
                        displayAggregatedMetrics(allMetricsData, dateRange);
                    }
                    exportCsvButton.classList.remove("hidden");
                } else {
                    metricsDisplay.innerHTML = `<p>No metric data available for the selected user and date(s).</p>`;
                }

            } catch (error) {
                console.error("Error fetching metrics:", error);
                let errorMessage = "Error fetching data. ";
                
                // Provide more helpful error messages based on the error type
                if (error.message.includes("Cannot read properties")) {
                    errorMessage = "Some metrics couldn't be displayed due to data format differences. This may happen if the user has a different device model or limited data availability for the selected period.";
                } else if (error.message) {
                    errorMessage += error.message;
                } else {
                    errorMessage += "Please try a different date range or contact support if the issue persists.";
                }
                
                displayError(dashboardError, errorMessage);
            } finally {
                loadingIndicator.style.display = "none";
                loadingIndicator.textContent = "Loading data...";
                fetchDataButton.disabled = false;
            }
        }

        function displayMetrics(metricData) {
            metricsDisplay.innerHTML = ""; // Clear previous content
            metricData.forEach(metric => {
                const card = document.createElement("div");
                card.className = "metric-card";
                
                // Check if metric has the expected structure
                if (!metric.object) {
                    console.error("Metric missing 'object' property:", metric);
                    return;
                }
                
                let content = `<h3>${metric.object.title || metric.type.replace("_", " ").toUpperCase()}</h3>`;
                let canvasId = `chart-${metric.type}-${Date.now()}`;

                // --- Specific Metric Handling ---
                switch (metric.type) {
                    case "sleep":
                    case "Sleep":
                        // Check if we have any sleep data at all
                        const hasAnyData = Object.keys(metric.object).length > 0;
                        const hasFullSleepData = metric.object.bedtime_start && metric.object.bedtime_end;
                        
                        if (hasFullSleepData) {
                            const bedtimeStart = new Date(metric.object.bedtime_start * 1000);
                            const bedtimeEnd = new Date(metric.object.bedtime_end * 1000);
                            const duration = (metric.object.bedtime_end - metric.object.bedtime_start) / 3600;
                            
                            // Instead of adding to current card, create multiple cards
                            card.innerHTML = content; // Finish the title card
                            metricsDisplay.appendChild(card); // Add the title card
                            
                            // 1. Bedtime Card
                            const bedtimeCard = document.createElement("div");
                            bedtimeCard.className = "metric-card";
                            bedtimeCard.innerHTML = `
                                <h3>BEDTIME</h3>
                                <div class="metric-value">${bedtimeStart.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })} <span class="metric-unit">Time</span></div>
                                <p class="metric-details">Sleep start time</p>
                            `;
                            metricsDisplay.appendChild(bedtimeCard);
                            
                            // 2. Wake Time Card
                            const wakeCard = document.createElement("div");
                            wakeCard.className = "metric-card";
                            wakeCard.innerHTML = `
                                <h3>WAKE TIME</h3>
                                <div class="metric-value">${bedtimeEnd.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })} <span class="metric-unit">Time</span></div>
                                <p class="metric-details">Sleep end time</p>
                            `;
                            metricsDisplay.appendChild(wakeCard);
                            
                            // 3. Sleep Duration Card
                            const durationCard = document.createElement("div");
                            durationCard.className = "metric-card";
                            durationCard.innerHTML = `
                                <h3>SLEEP DURATION</h3>
                                <div class="metric-value">${duration.toFixed(1)} <span class="metric-unit">hours</span></div>
                                <p class="metric-details">Total time in bed</p>
                            `;
                            metricsDisplay.appendChild(durationCard);
                            
                            // 4. Sleep Heart Rate Card
                            if (metric.object.hr_graph && metric.object.hr_graph.gist_object) {
                                const hrGist = metric.object.hr_graph.gist_object;
                                const hrCard = document.createElement("div");
                                hrCard.className = "metric-card";
                                const hrCanvasId = `hr-sleep-${Date.now()}`;
                                hrCard.innerHTML = `
                                    <h3>SLEEP HEART RATE</h3>
                                    <div class="metric-value">${hrGist.detail_text || hrGist.min || "N/A"} <span class="metric-unit">BPM</span></div>
                                    <p class="metric-details">${hrGist.title || "Lowest HR during sleep"}</p>
                                    <p class="metric-details">${hrGist.subtitle || ""}</p>
                                    <div class="chart-container"><canvas id="${hrCanvasId}"></canvas></div>
                                `;
                                metricsDisplay.appendChild(hrCard);
                                
                                // Add HR chart
                                if (metric.object.hr_graph.data && metric.object.hr_graph.data.length > 0) {
                                    const hrData = metric.object.hr_graph.data;
                                    const hrLabels = hrData.map(d => new Date(d.timestamp * 1000));
                                    const hrValues = hrData.map(d => d.value);
                                    setTimeout(() => createLineChart(hrCanvasId, hrLabels, hrValues, "Heart Rate (BPM)"), 0);
                                }
                            }
                            
                            // 5. Sleep HRV Card
                            if (metric.object.hrv_graph && metric.object.hrv_graph.gist_object) {
                                const hrvGist = metric.object.hrv_graph.gist_object;
                                const hrvCard = document.createElement("div");
                                hrvCard.className = "metric-card";
                                const hrvCanvasId = `hrv-sleep-${Date.now()}`;
                                hrvCard.innerHTML = `
                                    <h3>SLEEP HRV</h3>
                                    <div class="metric-value">${hrvGist.detail_text || "N/A"} <span class="metric-unit">ms</span></div>
                                    <p class="metric-details">${hrvGist.title || "HRV zone during sleep"}</p>
                                    <p class="metric-details">${hrvGist.subtitle || ""}</p>
                                    <div class="chart-container"><canvas id="${hrvCanvasId}"></canvas></div>
                                `;
                                metricsDisplay.appendChild(hrvCard);
                                
                                // Add HRV chart
                                if (metric.object.hrv_graph.data && metric.object.hrv_graph.data.length > 0) {
                                    const hrvData = metric.object.hrv_graph.data;
                                    const hrvLabels = hrvData.map(d => new Date(d.timestamp * 1000));
                                    const hrvValues = hrvData.map(d => d.value);
                                    setTimeout(() => createLineChart(hrvCanvasId, hrvLabels, hrvValues, "HRV (ms)"), 0);
                                }
                            }
                            
                            // Skip the normal card creation for sleep since we created multiple cards
                            return;
                        } else if (!hasAnyData) {
                            // Handle empty Sleep objects (no data available)
                            content += `<div class="metric-value">No Data <span class="metric-unit">Available</span></div>`;
                            content += `<p class="metric-details">No sleep data recorded for this date</p>`;
                        } else {
                            // Fallback for other sleep data formats (score-based, etc.)
                            content += `<div class="metric-value">${metric.object.score || "N/A"} <span class="metric-unit">Score</span></div>`;
                            if (metric.object.subtitle) content += `<p class="metric-details">${metric.object.subtitle}</p>`;
                        }
                        break;
                    case "hr":
                    case "temp":
                    case "hrv": // HRV average is often a key metric
                    case "night_rhr":
                        // For HR/HRV/Temp data with values array containing timestamp/value objects
                        if (metric.object.values && metric.object.values.length > 0) {
                            const displayValue = metric.object.avg || metric.object.last_reading || "N/A";
                            content += `<div class="metric-value">${displayValue} <span class="metric-unit">${metric.object.unit || (metric.type === "hrv" ? "ms" : "BPM")}</span></div>`;
                            
                            // Add subtitle if present
                            if (metric.object.subtitle) content += `<p class="metric-details">${metric.object.subtitle}</p>`;
                            if (metric.object.trend_direction && metric.object.trend_title) {
                                content += `<p class="metric-details">Trend: ${metric.object.trend_title}</p>`;
                            }
                            
                            content += `<div class="chart-container"><canvas id="${canvasId}"></canvas></div>`;
                            // Values array contains objects with timestamp and value
                            const labels = metric.object.values.map(v => new Date(v.timestamp * 1000));
                            const dataPoints = metric.object.values.map(v => v.value);
                            setTimeout(() => createLineChart(canvasId, labels, dataPoints, metric.object.title || metric.type), 0);
                        } else {
                            // Fallback for other formats
                            content += `<div class="metric-value">${metric.object.avg ?? metric.object.last_reading ?? metric.object.value ?? "N/A"} <span class="metric-unit">${metric.object.unit || (metric.type === "hrv" ? "ms" : ".")}</span></div>`;
                            if (metric.object.subtitle) content += `<p class="metric-details">(${metric.object.subtitle})</p>`;
                        }
                        break;
                    case "steps":
                    case "motion": // Assuming motion index
                        content += `<div class="metric-value">${metric.object.avg ? metric.object.avg.toFixed(0) : "N/A"} <span class="metric-unit">${metric.type === "steps" ? "Steps" : "Index"}</span></div>`;
                        if (metric.object.subtitle) content += `<p class="metric-details">(${metric.object.subtitle})</p>`;
                        // Could add chart for values over time if useful
                        break;
                    case "recovery": // Recovery Index
                    case "movement": // Movement Index
                        content += `<div class="metric-value">${metric.object.score ?? "N/A"} <span class="metric-unit">Index</span></div>`;
                        if (metric.object.state_title) content += `<p class="metric-details">State: ${metric.object.state_title}</p>`;
                        break;
                    case "recovery_index":
                        content += `<div class="metric-value">${metric.object.value || "N/A"} <span class="metric-unit">${metric.object.title || "Recovery Index"}</span></div>`;
                        break;
                    case "movement_index":
                        content += `<div class="metric-value">${metric.object.value || "N/A"} <span class="metric-unit">${metric.object.title || "Movement Index"}</span></div>`;
                        break;
                    case "avg_sleep_hrv":
                        content += `<div class="metric-value">${metric.object.value || "N/A"} <span class="metric-unit">ms</span></div>`;
                        break;
                    case "active_minutes":
                        content += `<div class="metric-value">${metric.object.value || "N/A"} <span class="metric-unit">${metric.object.title || "Active Minutes"}</span></div>`;
                        break;
                    case "sleep_rhr":
                        content += `<div class="metric-value">${metric.object.value || "N/A"} <span class="metric-unit">BPM</span></div>`;
                        break;
                    case "resting_hr":
                        // Handle resting HR with values array
                        if (metric.object.values && metric.object.values.length > 0) {
                            content += `<div class="metric-value">${metric.object.last_reading || "N/A"} <span class="metric-unit">${metric.object.unit || "BPM"}</span></div>`;
                            content += `<div class="chart-container"><canvas id="${canvasId}"></canvas></div>`;
                            const dataPoints = metric.object.values;
                            const labels = dataPoints.map((_, index) => index);
                            setTimeout(() => createLineChart(canvasId, labels, dataPoints, metric.object.title || "Resting HR"), 0);
                        } else {
                            content += `<div class="metric-value">N/A <span class="metric-unit">BPM</span></div>`;
                        }
                        break;
                    // Glucose related metrics (assuming structure from initial doc)
                    case "glucose": // Assuming this might be an average or latest reading
                    case "metabolic_score":
                    case "glucose_variability":
                    case "average_glucose":
                    case "hba1c":
                    case "time_in_target":
                    case "vo2_max":
                        // Generic display - adjust if sample provides more structure
                        content += `<div class="metric-value">${metric.object.value ?? metric.object.score ?? metric.object.avg ?? "N/A"} <span class="metric-unit">${metric.object.unit || ""}</span></div>`;
                        if (metric.object.title) content += `<p class="metric-details">(${metric.object.title})</p>`;
                        break;
                    default:
                        content += `<p class="metric-details">Data structure not fully recognized for type: ${metric.type}</p>`;
                        content += `<pre>${JSON.stringify(metric.object, null, 2)}</pre>`; // Show raw data for unrecognized types
                }

                card.innerHTML = content;
                metricsDisplay.appendChild(card);
            });
        }

        function displayAggregatedMetrics(allMetricsData, dateRange) {
            try {
            metricsDisplay.innerHTML = ""; // Clear previous content
            
            // Group metrics by type
            const metricsByType = {};
            allMetricsData.forEach(metric => {
                if (!metricsByType[metric.type]) {
                    metricsByType[metric.type] = [];
                }
                metricsByType[metric.type].push(metric);
            });

            // Display aggregated data for each metric type
            Object.keys(metricsByType).forEach(metricType => {
                const metrics = metricsByType[metricType];
                const card = document.createElement("div");
                card.className = "metric-card";
                
                let content = `<h3>${metricType.replace("_", " ").toUpperCase()} (${dateRange.length} days)</h3>`;
                
                // Calculate aggregations based on metric type
                switch (metricType) {
                    case "sleep":
                    case "Sleep":
                        // Create separate sleep analytics cards for multi-day view
                        let totalSleepHours = 0;
                        let totalHR = 0;
                        let totalHRV = 0;
                        let validSleepCount = 0;
                        let validHRCount = 0;
                        let validHRVCount = 0;
                        let bedtimes = [];
                        let waketimes = [];
                        
                        metrics.forEach(m => {
                            const hasValidSleepData = m.object.bedtime_start && m.object.bedtime_end;
                            if (hasValidSleepData) {
                                const duration = (m.object.bedtime_end - m.object.bedtime_start) / 3600;
                                totalSleepHours += duration;
                                validSleepCount++;
                                
                                // Collect bedtimes and wake times for consistency analysis
                                const bedtime = new Date(m.object.bedtime_start * 1000);
                                const waketime = new Date(m.object.bedtime_end * 1000);
                                bedtimes.push(bedtime.getHours() + bedtime.getMinutes() / 60);
                                waketimes.push(waketime.getHours() + waketime.getMinutes() / 60);
                            }
                            
                            // Handle HR data from multiple possible locations
                            const hrFromGraph = safeGet(m.object, 'hr_graph.gist_object.avg');
                            const hrFromQuickMetrics = m.object.quick_metrics?.find(
                                metric => metric.type === 'avg_hr'
                            )?.value;
                            const hrValue = hrFromGraph || hrFromQuickMetrics;
                            
                            if (hrValue) {
                                totalHR += hrValue;
                                validHRCount++;
                            }
                            
                            // Handle HRV data from multiple possible locations
                            const hrvFromGraph = safeGet(m.object, 'hrv_graph.gist_object.avg');
                            const hrvFromQuickMetrics = m.object.quick_metrics?.find(
                                metric => metric.type === 'avg_hrv'
                            )?.value;
                            const hrvValue = hrvFromGraph || hrvFromQuickMetrics;
                            
                            if (hrvValue) {
                                totalHRV += hrvValue;
                                validHRVCount++;
                            }
                        });
                        
                        // Create main sleep summary card
                        content += `<div class="metric-value">${validSleepCount}/${metrics.length} <span class="metric-unit">nights</span></div>`;
                        content += `<p class="metric-details">Nights with sleep data</p>`;
                        card.innerHTML = content;
                        metricsDisplay.appendChild(card);
                        
                        // Create separate cards for each sleep metric
                        if (validSleepCount > 0) {
                            // Average Sleep Duration
                            const avgSleepHours = totalSleepHours / validSleepCount;
                            const durationCard = document.createElement("div");
                            durationCard.className = "metric-card";
                            durationCard.innerHTML = `
                                <h3>AVG SLEEP DURATION (${dateRange.length} days)</h3>
                                <div class="metric-value">${avgSleepHours.toFixed(1)} <span class="metric-unit">hours</span></div>
                                <p class="metric-details">Average nightly sleep duration</p>
                            `;
                            metricsDisplay.appendChild(durationCard);
                            
                            // Average Bedtime
                            if (bedtimes.length > 0) {
                                const avgBedtime = bedtimes.reduce((sum, time) => sum + time, 0) / bedtimes.length;
                                const bedtimeHour = Math.floor(avgBedtime);
                                const bedtimeMin = Math.round((avgBedtime - bedtimeHour) * 60);
                                const bedtimeCard = document.createElement("div");
                                bedtimeCard.className = "metric-card";
                                bedtimeCard.innerHTML = `
                                    <h3>AVG BEDTIME (${dateRange.length} days)</h3>
                                    <div class="metric-value">${bedtimeHour}:${bedtimeMin.toString().padStart(2, '0')} <span class="metric-unit">PM</span></div>
                                    <p class="metric-details">Average sleep start time</p>
                                `;
                                metricsDisplay.appendChild(bedtimeCard);
                            }
                            
                            // Average Wake Time
                            if (waketimes.length > 0) {
                                const avgWaketime = waketimes.reduce((sum, time) => sum + time, 0) / waketimes.length;
                                const waketimeHour = Math.floor(avgWaketime);
                                const waketimeMin = Math.round((avgWaketime - waketimeHour) * 60);
                                const waketimeCard = document.createElement("div");
                                waketimeCard.className = "metric-card";
                                waketimeCard.innerHTML = `
                                    <h3>AVG WAKE TIME (${dateRange.length} days)</h3>
                                    <div class="metric-value">${waketimeHour}:${waketimeMin.toString().padStart(2, '0')} <span class="metric-unit">AM</span></div>
                                    <p class="metric-details">Average wake up time</p>
                                `;
                                metricsDisplay.appendChild(waketimeCard);
                            }
                        }
                        
                        if (validHRCount > 0) {
                            const avgHR = totalHR / validHRCount;
                            const hrCard = document.createElement("div");
                            hrCard.className = "metric-card";
                            hrCard.innerHTML = `
                                <h3>AVG SLEEP HEART RATE (${dateRange.length} days)</h3>
                                <div class="metric-value">${avgHR.toFixed(0)} <span class="metric-unit">BPM</span></div>
                                <p class="metric-details">Average heart rate during sleep</p>
                            `;
                            metricsDisplay.appendChild(hrCard);
                        }
                        
                        if (validHRVCount > 0) {
                            const avgHRV = totalHRV / validHRVCount;
                            const hrvCard = document.createElement("div");
                            hrvCard.className = "metric-card";
                            hrvCard.innerHTML = `
                                <h3>AVG SLEEP HRV (${dateRange.length} days)</h3>
                                <div class="metric-value">${avgHRV.toFixed(0)} <span class="metric-unit">ms</span></div>
                                <p class="metric-details">Average HRV during sleep</p>
                            `;
                            metricsDisplay.appendChild(hrvCard);
                        }
                        
                        // Skip normal card creation since we created multiple cards
                        return;
                        break;
                    case "hr":
                    case "temp":
                    case "hrv":
                    case "night_rhr":
                        // Filter out invalid metrics and safely extract values
                        const validMetrics = metrics.filter(m => m && m.object);
                        const avgValue = validMetrics.reduce((sum, m) => {
                            const avg = safeGet(m, 'object.avg', 0);
                            const lastReading = safeGet(m, 'object.last_reading', 0);
                            const value = safeGet(m, 'object.value', 0);
                            return sum + (avg || lastReading || value || 0);
                        }, 0) / (validMetrics.length || 1);
                        
                        const unit = safeGet(validMetrics[0], 'object.unit', '') || (metricType === "hrv" ? "ms" : "");
                        content += `<div class="metric-value">${avgValue.toFixed(1)} <span class="metric-unit">${unit} (Avg)</span></div>`;
                        
                        // Show range if available - use safe extraction
                        const hrValues = validMetrics.map(m => {
                            const avg = safeGet(m, 'object.avg', 0);
                            const lastReading = safeGet(m, 'object.last_reading', 0);
                            const value = safeGet(m, 'object.value', 0);
                            return avg || lastReading || value || 0;
                        }).filter(v => v > 0);
                        if (hrValues.length > 0) {
                            const minVal = Math.min(...hrValues);
                            const maxVal = Math.max(...hrValues);
                            content += `<p class="metric-details">Range: ${minVal.toFixed(1)} - ${maxVal.toFixed(1)} ${unit}</p>`;
                        }
                        break;
                    case "steps":
                        const totalSteps = metrics.reduce((sum, m) => sum + (m.object.avg || m.object.value || 0), 0);
                        const avgSteps = totalSteps / metrics.length;
                        content += `<div class="metric-value">${totalSteps.toFixed(0)} <span class="metric-unit">Total Steps</span></div>`;
                        content += `<p class="metric-details">Daily Average: ${avgSteps.toFixed(0)} steps</p>`;
                        break;
                    case "avg_sleep_hrv":
                        const avgSleepHrv = metrics.reduce((sum, m) => sum + (m.object.value || 0), 0) / metrics.length;
                        content += `<div class="metric-value">${avgSleepHrv.toFixed(0)} <span class="metric-unit">ms (Avg)</span></div>`;
                        break;
                    case "recovery_index":
                    case "movement_index":
                        const avgIndex = metrics.reduce((sum, m) => sum + (m.object.value || 0), 0) / metrics.length;
                        content += `<div class="metric-value">${avgIndex.toFixed(0)} <span class="metric-unit">Index (Avg)</span></div>`;
                        break;
                    case "active_minutes":
                        const totalMinutes = metrics.reduce((sum, m) => sum + (m.object.value || 0), 0);
                        const avgMinutes = totalMinutes / metrics.length;
                        content += `<div class="metric-value">${totalMinutes} <span class="metric-unit">Total Minutes</span></div>`;
                        content += `<p class="metric-details">Daily Average: ${avgMinutes.toFixed(0)} minutes</p>`;
                        break;
                    case "sleep_rhr":
                        const avgSleepRhr = metrics.reduce((sum, m) => sum + (m.object.value || 0), 0) / metrics.length;
                        content += `<div class="metric-value">${avgSleepRhr.toFixed(0)} <span class="metric-unit">BPM (Avg)</span></div>`;
                        break;
                    case "vo2_max":
                        const avgVo2 = metrics.reduce((sum, m) => sum + (m.object.value || 0), 0) / metrics.length;
                        content += `<div class="metric-value">${avgVo2.toFixed(0)} <span class="metric-unit">ml/kg/min (Avg)</span></div>`;
                        break;
                    case "glucose":
                    case "metabolic_score":
                    case "glucose_variability":
                    case "average_glucose":
                    case "hba1c":
                    case "time_in_target":
                        const glucoseValues = metrics.map(m => m.object.value || 0).filter(v => v > 0);
                        if (glucoseValues.length > 0) {
                            const avgVal = glucoseValues.reduce((sum, v) => sum + v, 0) / glucoseValues.length;
                            const unitStr = metricType.includes("score") ? "Score" : metricType.includes("variability") || metricType.includes("target") ? "%" : "mg/dL";
                            content += `<div class="metric-value">${avgVal.toFixed(1)} <span class="metric-unit">${unitStr} (Avg)</span></div>`;
                        } else {
                            content += `<p class="metric-details">No data available</p>`;
                        }
                        break;
                    default:
                        // For unrecognized types, try to show value if available
                        const genericValues = metrics.map(m => m.object.value || 0).filter(v => v > 0);
                        if (genericValues.length > 0) {
                            const avg = genericValues.reduce((sum, v) => sum + v, 0) / genericValues.length;
                            content += `<div class="metric-value">${avg.toFixed(1)} <span class="metric-unit">(Avg)</span></div>`;
                        } else {
                            content += `<p class="metric-details">${metrics.length} data points collected</p>`;
                        }
                }
                
                // Add date range info
                content += `<p class="metric-details">Period: ${dateRange[0]} to ${dateRange[dateRange.length - 1]}</p>`;
                
                card.innerHTML = content;
                metricsDisplay.appendChild(card);
            });
            } catch (error) {
                console.error("Error displaying aggregated metrics:", error);
                // Display partial results if possible
                if (metricsDisplay.innerHTML === "") {
                    metricsDisplay.innerHTML = `<div class="error">Unable to display some metrics due to data format issues. This may occur for users with different device models or limited data availability.</div>`;
                }
                // Re-throw to be caught by the parent try-catch
                throw error;
            }
        }

        function exportToCSV() {
            if (!currentMetricsData || currentMetricsData.length === 0) {
                displayError(dashboardError, "No data available to export.");
                return;
            }

            // Get selected user info
            const selectedUserId = userSelect.value;
            const selectedUserText = userSelect.options[userSelect.selectedIndex].text;
            const userEmail = selectedUserText.split(' (ID:')[0]; // Extract email from "email (ID: X)" format

            // Prepare CSV data
            const csvRows = [];
            const headers = ["User Email", "Date", "Metric Type", "Value", "Unit", "Details"];
            csvRows.push(headers.join(","));

            currentMetricsData.forEach(metric => {
                const date = metric.date || "N/A";
                const type = metric.type || "N/A";

                // Handle sleep metrics by creating multiple CSV rows for each sleep component
                if (metric.type === "sleep" || metric.type === "Sleep") {
                    const hasAnyData = Object.keys(metric.object).length > 0;
                    const hasFullSleepData = metric.object.bedtime_start && metric.object.bedtime_end;
                    
                    if (hasFullSleepData) {
                        const bedtimeStart = new Date(metric.object.bedtime_start * 1000);
                        const bedtimeEnd = new Date(metric.object.bedtime_end * 1000);
                        const duration = (metric.object.bedtime_end - metric.object.bedtime_start) / 3600;
                        
                        // Bedtime
                        csvRows.push([
                            userEmail,
                            date,
                            "Bedtime",
                            bedtimeStart.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }),
                            "Time",
                            "Sleep start time"
                        ].join(","));
                        
                        // Wake time
                        csvRows.push([
                            userEmail,
                            date,
                            "Wake Time",
                            bedtimeEnd.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }),
                            "Time",
                            "Sleep end time"
                        ].join(","));
                        
                        // Sleep duration
                        csvRows.push([
                            userEmail,
                            date,
                            "Sleep Duration",
                            duration.toFixed(1),
                            "hours",
                            "Total time in bed"
                        ].join(","));
                        
                        // Sleep heart rate metrics
                        if (metric.object.hr_graph && metric.object.hr_graph.gist_object) {
                            const hrGist = metric.object.hr_graph.gist_object;
                            csvRows.push([
                                userEmail,
                                date,
                                "Sleep Heart Rate (Lowest)",
                                hrGist.detail_text || hrGist.min || "N/A",
                                "BPM",
                                hrGist.title || "Lowest heart rate during sleep"
                            ].join(","));
                            
                            if (hrGist.avg) {
                                csvRows.push([
                                    userEmail,
                                    date,
                                    "Sleep Heart Rate (Average)",
                                    hrGist.avg,
                                    "BPM",
                                    "Average heart rate during sleep"
                                ].join(","));
                            }
                        }
                        
                        // Sleep HRV metrics
                        if (metric.object.hrv_graph && metric.object.hrv_graph.gist_object) {
                            const hrvGist = metric.object.hrv_graph.gist_object;
                            csvRows.push([
                                userEmail,
                                date,
                                "Sleep HRV Zone",
                                hrvGist.detail_text || "N/A",
                                "ms",
                                hrvGist.title || "HRV zone during sleep"
                            ].join(","));
                            
                            if (hrvGist.avg) {
                                csvRows.push([
                                    userEmail,
                                    date,
                                    "Sleep HRV (Average)",
                                    hrvGist.avg,
                                    "ms",
                                    "Average HRV during sleep"
                                ].join(","));
                            }
                        }
                    } else if (!hasAnyData) {
                        // Handle empty Sleep objects - no data available
                        csvRows.push([
                            userEmail,
                            date,
                            "Sleep Status",
                            "No Data Available",
                            "Status",
                            "No sleep data recorded for this date"
                        ].join(","));
                    } else {
                        // Fallback for other sleep data formats (score-based, etc.)
                        csvRows.push([
                            userEmail,
                            date,
                            type,
                            metric.object.score || metric.object.value || "N/A",
                            "Score",
                            metric.object.subtitle || ""
                        ].join(","));
                    }
                } else {
                    // Handle non-sleep metrics with original logic
                    let value = "N/A";
                    let unit = "";
                    let details = "";

                    switch (metric.type) {
                    case "hr":
                    case "heart_rate":
                        value = metric.object.avg || metric.object.last_reading || metric.object.value || "N/A";
                        unit = metric.object.unit || "BPM";
                        details = metric.object.subtitle || metric.object.title || "";
                        break;
                    case "temp":
                    case "temperature":
                        value = metric.object.avg || metric.object.last_reading || metric.object.value || "N/A";
                        unit = metric.object.unit || "°C";
                        details = metric.object.subtitle || metric.object.title || "";
                        break;
                    case "hrv":
                    case "heart_rate_variability":
                        value = metric.object.avg || metric.object.last_reading || metric.object.value || "N/A";
                        unit = metric.object.unit || "ms";
                        details = metric.object.subtitle || metric.object.title || "";
                        break;
                    case "night_rhr":
                    case "resting_heart_rate":
                        value = metric.object.avg || metric.object.last_reading || metric.object.value || "N/A";
                        unit = metric.object.unit || "BPM";
                        details = metric.object.subtitle || metric.object.title || "Sleep Time Average";
                        break;
                    case "avg_sleep_hrv":
                        value = metric.object.avg || metric.object.value || "N/A";
                        unit = metric.object.unit || "ms";
                        details = "Average Sleep HRV";
                        break;
                    case "steps":
                        value = metric.object.avg || metric.object.total || metric.object.value || "N/A";
                        unit = "Steps";
                        details = metric.object.subtitle || metric.object.title || "";
                        break;
                    case "glucose":
                        // Handle glucose with values array or direct value
                        if (metric.object.values && metric.object.values.length > 0) {
                            // Calculate average from values array
                            const avgGlucose = metric.object.values.reduce((sum, v) => sum + (v.value || v), 0) / metric.object.values.length;
                            value = avgGlucose.toFixed(1);
                        } else {
                            value = metric.object.avg || metric.object.value || metric.object.last_reading || "N/A";
                        }
                        unit = metric.object.unit || "mg/dL";
                        details = metric.object.title || "Glucose";
                        break;
                    case "metabolic_score":
                        value = metric.object.score || metric.object.value || "N/A";
                        unit = metric.object.unit || "Score";
                        details = "Metabolic Score";
                        break;
                    case "glucose_variability":
                        value = metric.object.percentage || metric.object.value || "N/A";
                        unit = metric.object.unit || "%";
                        details = "Glucose Variability";
                        break;
                    case "average_glucose":
                        value = metric.object.avg || metric.object.value || "N/A";
                        unit = metric.object.unit || "mg/dL";
                        details = "Average Glucose";
                        break;
                    case "hba1c":
                        value = metric.object.value || metric.object.percentage || "N/A";
                        unit = metric.object.unit || "%";
                        details = "HbA1c";
                        break;
                    case "time_in_target":
                        value = metric.object.percentage || metric.object.value || "N/A";
                        unit = metric.object.unit || "%";
                        details = "Time in Target";
                        break;
                    case "recovery_index":
                        value = metric.object.value || metric.object.score || metric.object.index || "N/A";
                        unit = metric.object.unit || "Index";
                        details = metric.object.title || "Recovery Index";
                        break;
                    case "movement_index":
                        value = metric.object.value || metric.object.score || metric.object.index || "N/A";
                        unit = metric.object.unit || "Index";
                        details = metric.object.title || "Movement Index";
                        break;
                    case "active_minutes":
                        value = metric.object.value || metric.object.total || "N/A";
                        unit = metric.object.unit || "Minutes";
                        details = metric.object.title || "Active Minutes";
                        break;
                    case "vo2_max":
                        value = metric.object.value || metric.object.score || "N/A";
                        unit = metric.object.unit || "ml/kg/min";
                        details = "VO2 Max";
                        break;
                    case "sleep_rhr":
                        value = metric.object.value || metric.object.avg || "N/A";
                        unit = metric.object.unit || "BPM";
                        details = "Sleep Resting Heart Rate";
                        break;
                    case "avg_sleep_hrv":
                        value = metric.object.value || "N/A";
                        unit = "ms";
                        details = "Average Sleep HRV";
                        break;
                    default:
                        // Generic fallback for unknown metric types
                        value = metric.object.value || metric.object.score || metric.object.avg || 
                               metric.object.total || metric.object.percentage || metric.object.index || 
                               metric.object.last_reading || "N/A";
                        unit = metric.object.unit || "";
                        details = metric.object.title || metric.object.subtitle || metric.object.description || "";
                    }

                    // Add CSV row for non-sleep metrics
                    // Escape commas and quotes in CSV data
                    const escapeCsvField = (field) => {
                        if (typeof field === "string" && (field.includes(",") || field.includes('"'))) {
                            return `"${field.replace(/"/g, '""')}"`;
                        }
                        return field;
                    };

                    csvRows.push([
                        escapeCsvField(userEmail),
                        escapeCsvField(date),
                        escapeCsvField(type),
                        escapeCsvField(value),
                        escapeCsvField(unit),
                        escapeCsvField(details)
                    ].join(","));
                }
            });

            // Continue with the rest of the CSV export function
            const csvContent = csvRows.join("\n");
            const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
            const url = URL.createObjectURL(blob);

            // Create download link
            const downloadLink = document.createElement("a");
            downloadLink.href = url;
            const dateStr = singleDateMode.checked ? dateSelect.value : `${startDateSelect.value}_to_${endDateSelect.value}`;
            downloadLink.download = `ultrahuman_data_${dateStr}.csv`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(url);
        }

        // --- Charting Functions ---
        function destroyCharts() {
            Object.values(currentChartInstances).forEach(chart => chart.destroy());
            currentChartInstances = {};
        }

        function createLineChart(canvasId, labels, data, label) {
            const ctx = document.getElementById(canvasId)?.getContext("2d");
            if (!ctx) return;
            currentChartInstances[canvasId] = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: data,
                        borderColor: "#007bff",
                        tension: 0.1,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: {
                                unit: "hour",
                                displayFormats: { hour: "HH:mm" }
                            },
                            title: { display: true, text: "Time" }
                        },
                        y: {
                            beginAtZero: false,
                            title: { display: true, text: "Value" }
                        }
                    }
                }
            });
        }

        function createDoughnutChart(canvasId, labels, data) {
            const ctx = document.getElementById(canvasId)?.getContext("2d");
            if (!ctx) return;
            currentChartInstances[canvasId] = new Chart(ctx, {
                type: "doughnut",
                data: {
                    labels: labels,
                    datasets: [{
                        label: "Sleep Stages",
                        data: data,
                        backgroundColor: [
                            "#0d6efd", // Deep
                            "#6c757d", // Light
                            "#198754", // REM
                            "#ffc107"  // Awake
                        ],
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || "";
                                    if (label) {
                                        label += ": ";
                                    }
                                    if (context.parsed !== null) {
                                        label += context.parsed.toFixed(2) + "%";
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        // --- Event Listeners ---
        showAddUserFormButton.addEventListener("click", () => showUserForm());
        cancelEditButton.addEventListener("click", hideUserForm);
        userForm.addEventListener("submit", saveUser);
        fetchDataButton.addEventListener("click", fetchMetrics);
        exportCsvButton.addEventListener("click", exportToCSV);
        singleDateMode.addEventListener("change", toggleDateMode);
        dateRangeMode.addEventListener("change", toggleDateMode);

        // --- Initial Load ---
        document.addEventListener("DOMContentLoaded", () => {
            fetchUsers();
            setDateToToday();
            toggleDateMode(); // Initialize date mode display
        });

    </script>
</body>
</html>

