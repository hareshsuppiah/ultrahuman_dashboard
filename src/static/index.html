<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultrahuman Device Dashboard</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background-color: #fafafa; 
            color: #333; 
            line-height: 1.6;
        } 
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background-color: #fff; 
            border-radius: 12px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.08); 
            overflow: hidden;
        } 
        .section { 
            padding: 32px; 
            border-bottom: 1px solid #eee; 
        } 
        .section:last-child { border-bottom: none; }
        h1 { 
            text-align: center; 
            color: #1a1a1a; 
            margin: 0 0 8px 0; 
            font-size: 2.25rem; 
            font-weight: 700; 
            letter-spacing: -0.025em;
        } 
        h2 { 
            margin: 0 0 24px 0; 
            color: #1a1a1a; 
            font-size: 1.5rem; 
            font-weight: 600; 
            border-bottom: 2px solid #1a1a1a; 
            padding-bottom: 8px;
        } 
        h3 { 
            color: #1a1a1a; 
            margin: 0 0 12px 0; 
            font-size: 1.125rem; 
            font-weight: 600;
        } 
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin: 24px 0; 
            background: #fff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06);
        } 
        th, td { 
            padding: 12px 16px; 
            text-align: left; 
            border-bottom: 1px solid #eee; 
            word-break: break-all; 
        } 
        th { 
            background-color: #f8f9fa; 
            font-weight: 600; 
            color: #1a1a1a;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        } 
        tr:hover { background-color: #f8f9fa; } 
        .form-group { 
            margin-bottom: 24px; 
        } 
        label { 
            display: block; 
            margin-bottom: 8px; 
            font-weight: 500; 
            color: #1a1a1a; 
            font-size: 0.875rem;
        } 
        input[type="text"], input[type="email"], input[type="date"], select { 
            width: 100%; 
            padding: 12px 16px; 
            border: 1px solid #d1d5db; 
            border-radius: 6px; 
            font-size: 0.875rem;
            transition: border-color 0.15s ease;
            background: #fff;
        } 
        input[type="text"]:focus, input[type="email"]:focus, input[type="date"]:focus, select:focus { 
            outline: none; 
            border-color: #1a1a1a; 
            box-shadow: 0 0 0 3px rgba(26, 26, 26, 0.1);
        }
        .radio-group {
            display: flex;
            gap: 24px;
            margin: 16px 0;
        }
        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .radio-option input[type="radio"] {
            width: auto;
            margin: 0;
        }
        .radio-option label {
            margin: 0;
            cursor: pointer;
            font-weight: 500;
            color: #6b7280;
        }
        .radio-option input[type="radio"]:checked + label {
            color: #1a1a1a;
        }
        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }
        button { 
            padding: 12px 24px; 
            background-color: #1a1a1a; 
            color: white; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 0.875rem; 
            font-weight: 500;
            transition: all 0.15s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        } 
        button:hover { 
            background-color: #374151; 
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        } 
        button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button.secondary { 
            background-color: #f3f4f6; 
            color: #374151; 
            border: 1px solid #d1d5db;
        } 
        button.secondary:hover { 
            background-color: #e5e7eb; 
            color: #1f2937;
        } 
        button.danger { 
            background-color: #ef4444; 
        } 
        button.danger:hover { 
            background-color: #dc2626; 
        } 
        .error { 
            color: #ef4444; 
            margin-top: 12px; 
            font-size: 0.875rem; 
            font-weight: 500;
            padding: 8px 12px;
            background: #fef2f2;
            border-radius: 6px;
            border-left: 4px solid #ef4444;
        } 
        .success { 
            color: #10b981; 
            margin-top: 12px; 
            font-size: 0.875rem; 
            font-weight: 500;
            padding: 8px 12px;
            background: #f0fdf4;
            border-radius: 6px;
            border-left: 4px solid #10b981;
        } 
        .metrics-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); 
            gap: 20px; 
            margin-top: 24px;
        } 
        .metric-card { 
            border: 1px solid #e5e7eb; 
            padding: 24px; 
            border-radius: 12px; 
            background-color: #fff; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.04); 
            max-height: 500px; 
            overflow-y: auto;
            transition: box-shadow 0.15s ease;
        } 
        .metric-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .metric-card h3 { 
            margin: 0 0 16px 0; 
            font-size: 1rem; 
            color: #1a1a1a; 
            border-bottom: 1px solid #e5e7eb; 
            padding-bottom: 8px; 
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.025em;
            font-size: 0.875rem;
        } 
        .metric-value { 
            font-size: 2rem; 
            font-weight: 700; 
            margin-bottom: 8px; 
            color: #1a1a1a; 
            line-height: 1;
        } 
        .metric-unit { 
            font-size: 0.875rem; 
            color: #6b7280; 
            margin-left: 8px; 
            font-weight: 500;
        } 
        .metric-details {
            font-size: 0.875rem;
            color: #6b7280;
            margin: 8px 0;
        }
        .stages-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        .stage-item {
            display: flex;
            flex-direction: column;
            padding: 12px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        .stage-label {
            font-size: 0.75rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.025em;
            margin-bottom: 4px;
        }
        .stage-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1a1a1a;
        }
        canvas { 
            max-width: 100%; 
            height: 250px !important; 
            margin-top: 16px; 
            display: block; 
            border-radius: 6px;
        }
        .chart-container { 
            height: 250px; 
            position: relative; 
            margin-top: 16px; 
        }
        /* Tab Navigation Styles */
        .tabs {
            display: flex;
            background-color: #f8f9fa;
            border-bottom: 2px solid #e5e7eb;
            margin: 0;
            padding: 0;
        }
        .tab-button {
            flex: 1;
            padding: 16px 24px;
            background: none;
            border: none;
            border-radius: 0;
            color: #6b7280;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
            box-shadow: none;
            transform: none;
        }
        .tab-button:hover {
            background-color: #f3f4f6;
            color: #1a1a1a;
            transform: none;
            box-shadow: none;
        }
        .tab-button.active {
            color: #1a1a1a;
            background-color: #fff;
            border-bottom: 3px solid #1a1a1a;
            margin-bottom: -2px;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        /* Multi-User Export Styles */
        .user-checkbox-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 12px;
            background-color: #f8f9fa;
            margin-bottom: 24px;
        }
        .user-checkbox-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin-bottom: 8px;
            background-color: #fff;
            border-radius: 4px;
            transition: background-color 0.15s ease;
        }
        .user-checkbox-item:hover {
            background-color: #f3f4f6;
        }
        .user-checkbox-item input[type="checkbox"] {
            margin-right: 12px;
            width: auto;
        }
        .user-checkbox-item label {
            margin: 0;
            font-weight: 500;
            cursor: pointer;
            flex: 1;
        }
        .select-all-container {
            padding: 12px;
            background-color: #e5e7eb;
            border-radius: 6px 6px 0 0;
            margin: -12px -12px 12px -12px;
            border-bottom: 1px solid #d1d5db;
        }
        #loading-indicator { 
            text-align: center; 
            padding: 24px; 
            font-size: 0.875rem; 
            color: #6b7280; 
            display: none;
            background: #f9fafb;
            border-radius: 6px;
            margin: 16px 0;
        } 
        .date-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Ultrahuman Ring Device Dashboard</h1>
        
        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('user-management')">User Management</button>
            <button class="tab-button" onclick="switchTab('single-dashboard')">Single User Dashboard</button>
            <button class="tab-button" onclick="switchTab('multi-export')">Multi-User Export</button>
        </div>

        <!-- User Management Tab -->
        <div class="section tab-content active" id="user-management">
            <h2>User Management</h2>
            <div id="user-list-section">
                <h3>Existing Users</h3>
                <table id="user-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Email</th>
                            <th>API Key (Partial)</th>
                            <th>Access Code</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- User rows will be populated by JavaScript -->
                    </tbody>
                </table>
                <button id="show-add-user-form">Add New User</button>
                <div id="user-list-message" class="success"></div>
            </div>

            <div id="user-form-section" style="display: none;">
                <h3 id="user-form-title">Add New User</h3>
                <form id="user-form">
                    <input type="hidden" id="user-id">
                    <div class="form-group">
                        <label for="email">Email:</label>
                        <input type="email" id="email" required>
                    </div>
                    <div class="form-group">
                        <label for="api-key">API Key:</label>
                        <input type="text" id="api-key" required>
                    </div>
                    <div class="form-group">
                        <label for="access-code">Access Code:</label>
                        <input type="text" id="access-code" required>
                    </div>
                    <div class="button-group">
                        <button type="submit" id="save-user-button">Save User</button>
                        <button type="button" id="cancel-edit-button" class="secondary">Cancel</button>
                    </div>
                </form>
                <div id="user-form-error" class="error"></div>
            </div>
        </div>

        <!-- Single User Dashboard Tab -->
        <div class="section tab-content" id="single-dashboard">
            <h2>Dashboard</h2>
            <div class="form-group">
                <label for="user-select">Select User:</label>
                <select id="user-select">
                    <option value="">-- Select a User --</option>
                    <!-- User options will be populated by JavaScript -->
                </select>
            </div>
            <div class="form-group">
                <label>Date Selection Mode</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="single-date-mode" name="date-mode" value="single" checked>
                        <label for="single-date-mode">Single Day</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="date-range-mode" name="date-mode" value="range">
                        <label for="date-range-mode">Date Range</label>
                    </div>
                </div>
            </div>
            <div class="form-group" id="single-date-group">
                <label for="date-select">Select Date</label>
                <input type="date" id="date-select">
            </div>
            <div class="form-group hidden" id="date-range-group">
                <label>Date Range</label>
                <div class="date-inputs">
                    <div>
                        <label for="start-date-select">Start Date</label>
                        <input type="date" id="start-date-select">
                    </div>
                    <div>
                        <label for="end-date-select">End Date</label>
                        <input type="date" id="end-date-select">
                    </div>
                </div>
            </div>
            <div class="button-group">
                <button id="fetch-data-button">Fetch Data</button>
                <button id="export-csv-button" class="secondary hidden">Export to CSV</button>
            </div>
            
            <!-- CSV Export Format Selection -->
            <div id="csv-format-selection" class="hidden" style="margin-top: 16px; padding: 16px; background: #f8f9fa; border-radius: 6px;">
                <h4 style="margin: 0 0 12px 0; color: #1a1a1a; font-size: 0.875rem;">CSV Export Format:</h4>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="single-format-long" name="single-csv-format" value="long" checked>
                        <label for="single-format-long">Long Format (one row per metric)</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="single-format-wide" name="single-csv-format" value="wide">
                        <label for="single-format-wide">Wide Format (one row per day, metrics as columns)</label>
                    </div>
                </div>
            </div>
            <div id="loading-indicator">Loading data...</div>
            <div id="dashboard-error" class="error"></div>

            <div id="metrics-display" class="metrics-grid" style="margin-top: 20px;">
                <!-- Metrics will be displayed here -->
            </div>
        </div>
        
        <!-- Multi-User Export Tab -->
        <div class="section tab-content" id="multi-export">
            <h2>Multi-User Data Export</h2>
            
            <div class="form-group">
                <h3>Select Users</h3>
                <div class="user-checkbox-list">
                    <div class="select-all-container">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="select-all-users" style="margin-right: 12px; width: auto;">
                            <strong>Select All Users</strong>
                        </label>
                    </div>
                    <div id="user-checkboxes">
                        <!-- User checkboxes will be populated here -->
                    </div>
                </div>
            </div>
            
            <div class="form-group">
                <h3>Select Date Range</h3>
                <div style="display: flex; gap: 16px;">
                    <div style="flex: 1;">
                        <label for="multi-start-date">Start Date:</label>
                        <input type="date" id="multi-start-date">
                    </div>
                    <div style="flex: 1;">
                        <label for="multi-end-date">End Date:</label>
                        <input type="date" id="multi-end-date">
                    </div>
                </div>
            </div>
            
            <!-- CSV Export Format Selection for Multi-User -->
            <div class="form-group">
                <h3>Export Format</h3>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="multi-format-long" name="multi-csv-format" value="long" checked>
                        <label for="multi-format-long">Long Format (one row per metric)</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="multi-format-wide" name="multi-csv-format" value="wide">
                        <label for="multi-format-wide">Wide Format (one row per day, metrics as columns)</label>
                    </div>
                </div>
            </div>
            
            <div class="button-group">
                <button id="multi-export-button">Export Selected Users Data to CSV</button>
            </div>
            
            <div id="multi-export-loading" style="display: none; text-align: center; padding: 20px; color: #6b7280;">
                <div style="font-size: 1.125rem; font-weight: 600;">Processing Export...</div>
                <div id="multi-export-progress" style="margin-top: 8px;">Initializing...</div>
            </div>
            
            <div id="multi-export-error" class="error" style="display: none;"></div>
            <div id="multi-export-success" class="success" style="display: none;"></div>
        </div>
    </div>

    <!-- Include Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <script>
        const userApiUrl = "/api/users"; // Relative path prefix
        const metricsApiUrlBase = "/api/metrics"; // Relative path prefix
        
        // Utility function for safe nested property access
        function safeGet(obj, path, defaultValue = null) {
            if (!obj || !path) return defaultValue;
            
            const keys = path.split('.');
            let result = obj;
            
            for (const key of keys) {
                if (result === null || result === undefined) {
                    return defaultValue;
                }
                result = result[key];
            }
            
            return result !== undefined ? result : defaultValue;
        }

        // Helper function to format duration in seconds to "Xh Ym" format with minutes
        function formatDuration(seconds) {
            if (seconds === null || seconds === undefined || isNaN(seconds)) {
                return { formatted: "N/A", totalMinutes: 0 };
            }
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.round((seconds % 3600) / 60);
            return {
                formatted: `${hours}h ${minutes}m`,
                totalMinutes: Math.round(seconds / 60)
            };
        }

        // Helper function to get value from quick_metrics array by type
        function getQuickMetric(quickMetrics, type) {
            if (!quickMetrics || !Array.isArray(quickMetrics)) return null;
            return quickMetrics.find(m => m.type === type);
        }

        // Helper function to process sleep_graph.data for derived metrics
        function processSleepGraphData(sleepGraphData) {
            if (!sleepGraphData || !Array.isArray(sleepGraphData) || sleepGraphData.length === 0) {
                return { hasData: false, deepSleepMin: 0, lightSleepMin: 0, remSleepMin: 0,
                         awakeMin: 0, sleepOnsetLatencyMin: 0, wasoMin: 0, wakeEpisodes: 0,
                         totalSleepDerivedMin: 0 };
            }

            let deepSleepSeconds = 0, lightSleepSeconds = 0, remSleepSeconds = 0, awakeSeconds = 0;
            const awakeSegments = [];

            sleepGraphData.forEach((segment, index) => {
                const duration = segment.end - segment.start;
                switch (segment.type) {
                    case 'deep_sleep': deepSleepSeconds += duration; break;
                    case 'light_sleep': lightSleepSeconds += duration; break;
                    case 'rem_sleep': remSleepSeconds += duration; break;
                    case 'awake':
                        awakeSeconds += duration;
                        awakeSegments.push({ index, duration });
                        break;
                }
            });

            // SOL: First awake segment if index === 0
            let solSeconds = (awakeSegments.length > 0 && awakeSegments[0].index === 0)
                             ? awakeSegments[0].duration : 0;

            // WASO: All awake segments AFTER first (includes final wake) - traditional definition
            let wasoSeconds = 0, wakeEpisodes = 0;
            if (awakeSegments.length > 1) {
                // Skip first segment (SOL), include all others including final
                awakeSegments.slice(1).forEach(seg => wasoSeconds += seg.duration);
                wakeEpisodes = awakeSegments.length - 1;
            }

            // Derived total sleep = Deep + Light + REM (from sleep_graph segments)
            const totalSleepDerivedSeconds = deepSleepSeconds + lightSleepSeconds + remSleepSeconds;

            return {
                hasData: true,
                deepSleepMin: Math.round(deepSleepSeconds / 60),
                lightSleepMin: Math.round(lightSleepSeconds / 60),
                remSleepMin: Math.round(remSleepSeconds / 60),
                awakeMin: Math.round(awakeSeconds / 60),
                sleepOnsetLatencyMin: Math.round(solSeconds / 60),
                wasoMin: Math.round(wasoSeconds / 60),
                wakeEpisodes: wakeEpisodes,
                totalSleepDerivedMin: Math.round(totalSleepDerivedSeconds / 60)
            };
        }

        // Helper function to get steps from metrics array
        function getStepsFromMetrics(metrics) {
            if (!metrics || !Array.isArray(metrics)) return 0;
            const stepsMetric = metrics.find(m => m.type === 'steps');
            // Use total (full day count) as primary, fall back to avg
            return stepsMetric ? (safeGet(stepsMetric, 'object.total') || safeGet(stepsMetric, 'object.avg') || 0) : 0;
        }

        const userTableBody = document.getElementById("user-table").querySelector("tbody");
        const userSelect = document.getElementById("user-select");
        const userFormSection = document.getElementById("user-form-section");
        const userListSection = document.getElementById("user-list-section");
        const userForm = document.getElementById("user-form");
        const userFormTitle = document.getElementById("user-form-title");
        const userIdInput = document.getElementById("user-id");
        const emailInput = document.getElementById("email");
        const apiKeyInput = document.getElementById("api-key");
        const accessCodeInput = document.getElementById("access-code");
        const userFormError = document.getElementById("user-form-error");
        const userListMessage = document.getElementById("user-list-message");
        const showAddUserFormButton = document.getElementById("show-add-user-form");
        const cancelEditButton = document.getElementById("cancel-edit-button");

        const dateSelect = document.getElementById("date-select");
        const startDateSelect = document.getElementById("start-date-select");
        const endDateSelect = document.getElementById("end-date-select");
        const singleDateMode = document.getElementById("single-date-mode");
        const dateRangeMode = document.getElementById("date-range-mode");
        const singleDateGroup = document.getElementById("single-date-group");
        const dateRangeGroup = document.getElementById("date-range-group");
        const fetchDataButton = document.getElementById("fetch-data-button");
        const exportCsvButton = document.getElementById("export-csv-button");
        const metricsDisplay = document.getElementById("metrics-display");
        const dashboardError = document.getElementById("dashboard-error");
        const loadingIndicator = document.getElementById("loading-indicator");

        let currentChartInstances = {}; // To keep track of chart instances
        let currentMetricsData = null; // Store current data for CSV export

        // --- Utility Functions ---
        function displayError(element, message) {
            element.textContent = message;
            element.style.display = "block";
        }

        function clearError(element) {
            element.textContent = "";
            element.style.display = "none";
        }

        function displaySuccess(element, message) {
            element.textContent = message;
            element.style.display = "block";
            setTimeout(() => { element.style.display = "none"; }, 3000); // Hide after 3 seconds
        }

        // --- User Management Functions ---
        async function fetchUsers() {
            try {
                const response = await fetch(userApiUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const users = await response.json();
                populateUserTable(users);
                populateUserSelect(users);
            } catch (error) {
                console.error("Error fetching users:", error);
                displayError(userListMessage, `Error loading users: ${error.message}`);
            }
        }

        function populateUserTable(users) {
            userTableBody.innerHTML = ""; // Clear existing rows
            if (users.length === 0) {
                userTableBody.innerHTML = `<tr><td colspan="5">No users found.</td></tr>`;
                return;
            }
            users.forEach(user => {
                const row = userTableBody.insertRow();
                const apiKeyPartial = user.api_key ? `${user.api_key.substring(0, 4)}...${user.api_key.substring(user.api_key.length - 4)}` : "N/A";
                row.innerHTML = `
                    <td>${user.id}</td>
                    <td>${user.email}</td>
                    <td>${apiKeyPartial}</td>
                    <td>${user.access_code}</td>
                    <td>
                        <button class="secondary" onclick="editUser(${user.id}, '${user.email}', '${user.api_key}', '${user.access_code}')">Edit</button>
                        <button class="danger" onclick="deleteUser(${user.id})">Delete</button>
                    </td>
                `;
            });
        }

        function populateUserSelect(users) {
            userSelect.innerHTML = `<option value="">-- Select a User --</option>`; // Clear existing options
            users.forEach(user => {
                const option = document.createElement("option");
                option.value = user.id;
                option.textContent = `${user.email} (ID: ${user.id})`;
                userSelect.appendChild(option);
            });
        }

        function showUserForm(isEdit = false, id = null, email = "", apiKey = "", accessCode = "") {
            userForm.reset();
            userIdInput.value = id || "";
            emailInput.value = email;
            apiKeyInput.value = apiKey;
            accessCodeInput.value = accessCode;
            userFormTitle.textContent = isEdit ? "Edit User" : "Add New User";
            clearError(userFormError);
            userListSection.style.display = "none";
            userFormSection.style.display = "block";
        }

        function hideUserForm() {
            userFormSection.style.display = "none";
            userListSection.style.display = "block";
            userForm.reset();
            userIdInput.value = "";
            clearError(userFormError);
        }

        async function saveUser(event) {
            event.preventDefault();
            clearError(userFormError);

            const id = userIdInput.value;
            const userData = {
                email: emailInput.value,
                api_key: apiKeyInput.value,
                access_code: accessCodeInput.value
            };

            const method = id ? "PUT" : "POST";
            const url = id ? `${userApiUrl}/${id}` : userApiUrl;

            try {
                const response = await fetch(url, {
                    method: method,
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(userData),
                });

                let result;
                try {
                    result = await response.json();
                } catch (jsonError) {
                    // If JSON parsing fails, get the text response for better error reporting
                    const textResponse = await response.text();
                    throw new Error(`Server returned invalid JSON. Status: ${response.status}. Response: ${textResponse.substring(0, 200)}...`);
                }

                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                hideUserForm();
                fetchUsers(); // Refresh user list and dropdown
                displaySuccess(userListMessage, `User ${id ? "updated" : "added"} successfully!`);
            } catch (error) {
                console.error("Error saving user:", error);
                displayError(userFormError, `Error saving user: ${error.message}`);
            }
        }

        function editUser(id, email, apiKey, accessCode) {
            showUserForm(true, id, email, apiKey, accessCode);
        }

        async function deleteUser(id) {
            if (!confirm(`Are you sure you want to delete user ID ${id}?`)) {
                return;
            }

            try {
                const response = await fetch(`${userApiUrl}/${id}`, {
                    method: "DELETE",
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                fetchUsers(); // Refresh user list and dropdown
                displaySuccess(userListMessage, `User deleted successfully!`);
            } catch (error) {
                console.error("Error deleting user:", error);
                displayError(userListMessage, `Error deleting user: ${error.message}`);
            }
        }

        // --- Dashboard Functions ---
        function toggleDateMode() {
            if (singleDateMode.checked) {
                singleDateGroup.classList.remove("hidden");
                dateRangeGroup.classList.add("hidden");
            } else {
                singleDateGroup.classList.add("hidden");
                dateRangeGroup.classList.remove("hidden");
            }
        }

        function setDateToToday() {
            const today = new Date().toISOString().split("T")[0];
            dateSelect.value = today;
            startDateSelect.value = today;
            endDateSelect.value = today;
        }

        function validateDateRange() {
            if (dateRangeMode.checked) {
                const startDate = new Date(startDateSelect.value);
                const endDate = new Date(endDateSelect.value);
                if (startDate > endDate) {
                    displayError(dashboardError, "Start date must be before or equal to end date.");
                    return false;
                }
                const daysDiff = (endDate - startDate) / (1000 * 60 * 60 * 24);
                if (daysDiff > 30) {
                    displayError(dashboardError, "Date range cannot exceed 30 days.");
                    return false;
                }
            }
            return true;
        }

        async function fetchMetrics() {
            const userId = userSelect.value;
            
            clearError(dashboardError);
            metricsDisplay.innerHTML = ""; // Clear previous metrics
            destroyCharts(); // Destroy old charts before creating new ones
            exportCsvButton.classList.add("hidden");
            document.getElementById("csv-format-selection").classList.add("hidden");
            currentMetricsData = null;

            if (!userId) {
                displayError(dashboardError, "Please select a user.");
                return;
            }

            // Validate date inputs based on mode
            if (singleDateMode.checked) {
                if (!dateSelect.value) {
                    displayError(dashboardError, "Please select a date.");
                    return;
                }
            } else {
                if (!startDateSelect.value || !endDateSelect.value) {
                    displayError(dashboardError, "Please select both start and end dates.");
                    return;
                }
                if (!validateDateRange()) {
                    return;
                }
            }

            loadingIndicator.style.display = "block";
            fetchDataButton.disabled = true;

            try {
                let allMetricsData = [];
                let dateRange = [];

                if (singleDateMode.checked) {
                    // Single date mode
                    dateRange = [dateSelect.value];
                } else {
                    // Date range mode - generate array of dates
                    const startDate = new Date(startDateSelect.value);
                    const endDate = new Date(endDateSelect.value);
                    
                    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                        dateRange.push(d.toISOString().split('T')[0]);
                    }
                }

                // Fetch data for each date
                for (let i = 0; i < dateRange.length; i++) {
                    const date = dateRange[i];
                    loadingIndicator.textContent = `Loading data... (${i + 1}/${dateRange.length})`;
                    
                    const response = await fetch(`${metricsApiUrlBase}/${userId}?date=${date}`);
                    const result = await response.json();

                    if (!response.ok) {
                        console.warn(`Failed to fetch data for ${date}: ${result.error}`);
                        continue;
                    }

                    if (result.data && result.data.metric_data) {
                        // Add date info to each metric
                        const dateMetrics = result.data.metric_data.map(metric => ({
                            ...metric,
                            date: date
                        }));
                        allMetricsData.push(...dateMetrics);
                        
                        // Debug: Log a sample metric to understand structure
                        if (dateMetrics.length > 0) {
                            console.log(`Sample metric for ${date}:`, dateMetrics[0]);
                        }
                    }
                }

                if (allMetricsData.length > 0) {
                    currentMetricsData = allMetricsData;
                    if (singleDateMode.checked) {
                        displayMetrics(allMetricsData);
                    } else {
                        displayAggregatedMetrics(allMetricsData, dateRange);
                    }
                    exportCsvButton.classList.remove("hidden");
                    document.getElementById("csv-format-selection").classList.remove("hidden");
                } else {
                    metricsDisplay.innerHTML = `<p>No metric data available for the selected user and date(s).</p>`;
                }

            } catch (error) {
                console.error("Error fetching metrics:", error);
                let errorMessage = "Error fetching data. ";
                
                // Provide more helpful error messages based on the error type
                if (error.message.includes("Cannot read properties")) {
                    errorMessage = "Some metrics couldn't be displayed due to data format differences. This may happen if the user has a different device model or limited data availability for the selected period.";
                } else if (error.message) {
                    errorMessage += error.message;
                } else {
                    errorMessage += "Please try a different date range or contact support if the issue persists.";
                }
                
                displayError(dashboardError, errorMessage);
            } finally {
                loadingIndicator.style.display = "none";
                loadingIndicator.textContent = "Loading data...";
                fetchDataButton.disabled = false;
            }
        }

        function displayMetrics(metricData) {
            metricsDisplay.innerHTML = ""; // Clear previous content
            metricData.forEach(metric => {
                const card = document.createElement("div");
                card.className = "metric-card";
                
                // Check if metric has the expected structure
                if (!metric.object) {
                    console.error("Metric missing 'object' property:", metric);
                    return;
                }
                
                let content = `<h3>${safeGet(metric, 'object.title') || metric.type.replace("_", " ").toUpperCase()}</h3>`;
                let canvasId = `chart-${metric.type}-${Date.now()}`;

                // --- Specific Metric Handling ---
                switch (metric.type) {
                    case "sleep":
                    case "Sleep":
                        // Check if we have any sleep data at all
                        const hasAnyData = Object.keys(metric.object).length > 0;
                        const hasFullSleepData = safeGet(metric, 'object.bedtime_start') && safeGet(metric, 'object.bedtime_end');
                        
                        if (hasFullSleepData) {
                            const bedtimeStart = new Date(safeGet(metric, 'object.bedtime_start') * 1000);
                            const bedtimeEnd = new Date(safeGet(metric, 'object.bedtime_end') * 1000);
                            const timeInBedSeconds = safeGet(metric, 'object.bedtime_end') - safeGet(metric, 'object.bedtime_start');
                            const timeInBed = formatDuration(timeInBedSeconds);

                            // Get total sleep and efficiency from quick_metrics if available
                            const quickMetrics = safeGet(metric, 'object.quick_metrics');
                            const totalSleepMetric = getQuickMetric(quickMetrics, 'total_sleep');
                            const sleepEfficiencyMetric = getQuickMetric(quickMetrics, 'sleep_efic');

                            const totalSleep = totalSleepMetric ? formatDuration(totalSleepMetric.value) : null;
                            const sleepEfficiency = sleepEfficiencyMetric ? sleepEfficiencyMetric.value : null;

                            // Instead of adding to current card, create multiple cards
                            card.innerHTML = content; // Finish the title card
                            metricsDisplay.appendChild(card); // Add the title card

                            // 1. Bedtime Card
                            const bedtimeCard = document.createElement("div");
                            bedtimeCard.className = "metric-card";
                            bedtimeCard.innerHTML = `
                                <h3>BEDTIME</h3>
                                <div class="metric-value">${bedtimeStart.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })} <span class="metric-unit">Time</span></div>
                                <p class="metric-details">Sleep start time</p>
                            `;
                            metricsDisplay.appendChild(bedtimeCard);

                            // 2. Wake Time Card
                            const wakeCard = document.createElement("div");
                            wakeCard.className = "metric-card";
                            wakeCard.innerHTML = `
                                <h3>WAKE TIME</h3>
                                <div class="metric-value">${bedtimeEnd.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })} <span class="metric-unit">Time</span></div>
                                <p class="metric-details">Sleep end time</p>
                            `;
                            metricsDisplay.appendChild(wakeCard);

                            // 3. Time in Bed Card
                            const timeInBedCard = document.createElement("div");
                            timeInBedCard.className = "metric-card";
                            timeInBedCard.innerHTML = `
                                <h3>TIME IN BED</h3>
                                <div class="metric-value">${timeInBed.formatted} <span class="metric-unit">(${timeInBed.totalMinutes} min)</span></div>
                                <p class="metric-details">From bedtime to wake time</p>
                            `;
                            metricsDisplay.appendChild(timeInBedCard);

                            // 4. Total Sleep Card (API value from quick_metrics)
                            if (totalSleep) {
                                const totalSleepCard = document.createElement("div");
                                totalSleepCard.className = "metric-card";
                                totalSleepCard.innerHTML = `
                                    <h3>TOTAL SLEEP (API)</h3>
                                    <div class="metric-value">${totalSleep.formatted} <span class="metric-unit">(${totalSleep.totalMinutes} min)</span></div>
                                    <p class="metric-details">From API quick_metrics</p>
                                `;
                                metricsDisplay.appendChild(totalSleepCard);
                            }

                            // 5. Sleep Efficiency Card (if available from quick_metrics)
                            if (sleepEfficiency !== null) {
                                const efficiencyCard = document.createElement("div");
                                efficiencyCard.className = "metric-card";
                                efficiencyCard.innerHTML = `
                                    <h3>SLEEP EFFICIENCY</h3>
                                    <div class="metric-value">${sleepEfficiency} <span class="metric-unit">%</span></div>
                                    <p class="metric-details">Total sleep / Time in bed</p>
                                `;
                                metricsDisplay.appendChild(efficiencyCard);
                            }

                            // 6. Derived Sleep Metrics from sleep_graph.data
                            const sleepGraphData = processSleepGraphData(safeGet(metric, 'object.sleep_graph.data'));
                            if (sleepGraphData.hasData) {
                                // Sleep Stages Card
                                const stagesCard = document.createElement("div");
                                stagesCard.className = "metric-card";
                                stagesCard.innerHTML = `
                                    <h3>SLEEP STAGES</h3>
                                    <div class="stages-grid">
                                        <div class="stage-item"><span class="stage-label">Deep</span><span class="stage-value">${sleepGraphData.deepSleepMin} min</span></div>
                                        <div class="stage-item"><span class="stage-label">Light</span><span class="stage-value">${sleepGraphData.lightSleepMin} min</span></div>
                                        <div class="stage-item"><span class="stage-label">REM</span><span class="stage-value">${sleepGraphData.remSleepMin} min</span></div>
                                        <div class="stage-item"><span class="stage-label">Awake</span><span class="stage-value">${sleepGraphData.awakeMin} min</span></div>
                                    </div>
                                `;
                                metricsDisplay.appendChild(stagesCard);

                                // Total Sleep (Derived) Card - calculated from Deep + Light + REM
                                const totalSleepDerivedCard = document.createElement("div");
                                totalSleepDerivedCard.className = "metric-card";
                                const derivedHours = Math.floor(sleepGraphData.totalSleepDerivedMin / 60);
                                const derivedMins = sleepGraphData.totalSleepDerivedMin % 60;
                                totalSleepDerivedCard.innerHTML = `
                                    <h3>TOTAL SLEEP (DERIVED)</h3>
                                    <div class="metric-value">${derivedHours}h ${derivedMins}m <span class="metric-unit">(${sleepGraphData.totalSleepDerivedMin} min)</span></div>
                                    <p class="metric-details">Deep + Light + REM from segments</p>
                                `;
                                metricsDisplay.appendChild(totalSleepDerivedCard);

                                // Sleep Onset Latency Card
                                const solCard = document.createElement("div");
                                solCard.className = "metric-card";
                                solCard.innerHTML = `
                                    <h3>SLEEP ONSET LATENCY</h3>
                                    <div class="metric-value">${sleepGraphData.sleepOnsetLatencyMin} <span class="metric-unit">min</span></div>
                                    <p class="metric-details">Time from bedtime to first sleep</p>
                                `;
                                metricsDisplay.appendChild(solCard);

                                // WASO Card
                                const wasoCard = document.createElement("div");
                                wasoCard.className = "metric-card";
                                wasoCard.innerHTML = `
                                    <h3>WASO</h3>
                                    <div class="metric-value">${sleepGraphData.wasoMin} <span class="metric-unit">min</span></div>
                                    <p class="metric-details">Wake After Sleep Onset</p>
                                `;
                                metricsDisplay.appendChild(wasoCard);

                                // Wake Episodes Card
                                const wakeEpisodesCard = document.createElement("div");
                                wakeEpisodesCard.className = "metric-card";
                                wakeEpisodesCard.innerHTML = `
                                    <h3>WAKE EPISODES</h3>
                                    <div class="metric-value">${sleepGraphData.wakeEpisodes} <span class="metric-unit">count</span></div>
                                    <p class="metric-details">Awakenings during sleep</p>
                                `;
                                metricsDisplay.appendChild(wakeEpisodesCard);

                            }

                            // 7. Sleep Heart Rate Card
                            if (safeGet(metric, 'object.hr_graph') && safeGet(metric, 'object.hr_graph.gist_object')) {
                                const hrGist = safeGet(metric, 'object.hr_graph.gist_object');
                                const hrCard = document.createElement("div");
                                hrCard.className = "metric-card";
                                const hrCanvasId = `hr-sleep-${Date.now()}`;
                                hrCard.innerHTML = `
                                    <h3>SLEEP HEART RATE</h3>
                                    <div class="metric-value">${hrGist.detail_text || hrGist.min || "N/A"} <span class="metric-unit">BPM</span></div>
                                    <p class="metric-details">${hrGist.title || "Lowest HR during sleep"}</p>
                                    <p class="metric-details">${hrGist.subtitle || ""}</p>
                                    <div class="chart-container"><canvas id="${hrCanvasId}"></canvas></div>
                                `;
                                metricsDisplay.appendChild(hrCard);
                                
                                // Add HR chart
                                if (safeGet(metric, 'object.hr_graph.data') && safeGet(metric, 'object.hr_graph.data').length > 0) {
                                    const hrData = safeGet(metric, 'object.hr_graph.data');
                                    const hrLabels = hrData.map(d => new Date(d.timestamp * 1000));
                                    const hrValues = hrData.map(d => d.value);
                                    setTimeout(() => createLineChart(hrCanvasId, hrLabels, hrValues, "Heart Rate (BPM)"), 0);
                                }
                            }
                            
                            // 7. Sleep HRV Card
                            if (safeGet(metric, 'object.hrv_graph') && safeGet(metric, 'object.hrv_graph.gist_object')) {
                                const hrvGist = safeGet(metric, 'object.hrv_graph.gist_object');
                                const hrvCard = document.createElement("div");
                                hrvCard.className = "metric-card";
                                const hrvCanvasId = `hrv-sleep-${Date.now()}`;
                                hrvCard.innerHTML = `
                                    <h3>SLEEP HRV</h3>
                                    <div class="metric-value">${hrvGist.detail_text || "N/A"} <span class="metric-unit">ms</span></div>
                                    <p class="metric-details">${hrvGist.title || "HRV zone during sleep"}</p>
                                    <p class="metric-details">${hrvGist.subtitle || ""}</p>
                                    <div class="chart-container"><canvas id="${hrvCanvasId}"></canvas></div>
                                `;
                                metricsDisplay.appendChild(hrvCard);
                                
                                // Add HRV chart
                                if (safeGet(metric, 'object.hrv_graph.data') && safeGet(metric, 'object.hrv_graph.data').length > 0) {
                                    const hrvData = safeGet(metric, 'object.hrv_graph.data');
                                    const hrvLabels = hrvData.map(d => new Date(d.timestamp * 1000));
                                    const hrvValues = hrvData.map(d => d.value);
                                    setTimeout(() => createLineChart(hrvCanvasId, hrvLabels, hrvValues, "HRV (ms)"), 0);
                                }
                            }
                            
                            // Skip the normal card creation for sleep since we created multiple cards
                            return;
                        } else if (!hasAnyData) {
                            // Handle empty Sleep objects (no data available)
                            content += `<div class="metric-value">No Data <span class="metric-unit">Available</span></div>`;
                            content += `<p class="metric-details">No sleep data recorded for this date</p>`;
                        } else {
                            // Fallback for other sleep data formats (score-based, etc.)
                            content += `<div class="metric-value">${safeGet(metric, 'object.score') || "N/A"} <span class="metric-unit">Score</span></div>`;
                            if (safeGet(metric, 'object.subtitle')) content += `<p class="metric-details">${safeGet(metric, 'object.subtitle')}</p>`;
                        }
                        break;
                    case "hr":
                    case "temp":
                    case "hrv": // HRV average is often a key metric
                    case "night_rhr":
                        // For HR/HRV/Temp data with values array containing timestamp/value objects
                        if (safeGet(metric, 'object.values') && safeGet(metric, 'object.values').length > 0) {
                            const displayValue = safeGet(metric, 'object.avg') || safeGet(metric, 'object.last_reading') || "N/A";
                            content += `<div class="metric-value">${displayValue} <span class="metric-unit">${safeGet(metric, 'object.unit') || (metric.type === "hrv" ? "ms" : "BPM")}</span></div>`;
                            
                            // Add subtitle if present
                            if (safeGet(metric, 'object.subtitle')) content += `<p class="metric-details">${safeGet(metric, 'object.subtitle')}</p>`;
                            if (safeGet(metric, 'object.trend_direction') && safeGet(metric, 'object.trend_title')) {
                                content += `<p class="metric-details">Trend: ${safeGet(metric, 'object.trend_title')}</p>`;
                            }
                            
                            content += `<div class="chart-container"><canvas id="${canvasId}"></canvas></div>`;
                            // Values array contains objects with timestamp and value
                            const labels = safeGet(metric, 'object.values').map(v => new Date(v.timestamp * 1000));
                            const dataPoints = safeGet(metric, 'object.values').map(v => v.value);
                            setTimeout(() => createLineChart(canvasId, labels, dataPoints, safeGet(metric, 'object.title') || metric.type), 0);
                        } else {
                            // Fallback for other formats
                            content += `<div class="metric-value">${safeGet(metric, 'object.avg') ?? safeGet(metric, 'object.last_reading') ?? safeGet(metric, 'object.value') ?? "N/A"} <span class="metric-unit">${safeGet(metric, 'object.unit') || (metric.type === "hrv" ? "ms" : ".")}</span></div>`;
                            if (safeGet(metric, 'object.subtitle')) content += `<p class="metric-details">(${safeGet(metric, 'object.subtitle')})</p>`;
                        }
                        break;
                    case "steps":
                        // Use total (full day count) as primary
                        const dailySteps = safeGet(metric, 'object.total') || safeGet(metric, 'object.avg') || 0;
                        content += `<div class="metric-value">${dailySteps ? dailySteps.toFixed(0) : "N/A"} <span class="metric-unit">Steps</span></div>`;
                        content += `<p class="metric-details">Daily total (calendar day)</p>`;
                        break;
                    case "motion": // Assuming motion index
                        content += `<div class="metric-value">${safeGet(metric, 'object.avg') ? safeGet(metric, 'object.avg').toFixed(0) : "N/A"} <span class="metric-unit">Index</span></div>`;
                        if (safeGet(metric, 'object.subtitle')) content += `<p class="metric-details">(${safeGet(metric, 'object.subtitle')})</p>`;
                        break;
                    case "recovery": // Recovery Index
                    case "movement": // Movement Index
                        content += `<div class="metric-value">${safeGet(metric, 'object.score') ?? "N/A"} <span class="metric-unit">Index</span></div>`;
                        if (safeGet(metric, 'object.state_title')) content += `<p class="metric-details">State: ${safeGet(metric, 'object.state_title')}</p>`;
                        break;
                    case "recovery_index":
                        content += `<div class="metric-value">${safeGet(metric, 'object.value') || "N/A"} <span class="metric-unit">${safeGet(metric, 'object.title') || "Recovery Index"}</span></div>`;
                        break;
                    case "movement_index":
                        content += `<div class="metric-value">${safeGet(metric, 'object.value') || "N/A"} <span class="metric-unit">${safeGet(metric, 'object.title') || "Movement Index"}</span></div>`;
                        break;
                    case "avg_sleep_hrv":
                        content += `<div class="metric-value">${safeGet(metric, 'object.value') || "N/A"} <span class="metric-unit">ms</span></div>`;
                        break;
                    case "active_minutes":
                        content += `<div class="metric-value">${safeGet(metric, 'object.value') || "N/A"} <span class="metric-unit">${safeGet(metric, 'object.title') || "Active Minutes"}</span></div>`;
                        break;
                    case "sleep_rhr":
                        content += `<div class="metric-value">${safeGet(metric, 'object.value') || "N/A"} <span class="metric-unit">BPM</span></div>`;
                        break;
                    case "resting_hr":
                        // Handle resting HR with values array
                        if (safeGet(metric, 'object.values') && safeGet(metric, 'object.values').length > 0) {
                            content += `<div class="metric-value">${safeGet(metric, 'object.last_reading') || "N/A"} <span class="metric-unit">${safeGet(metric, 'object.unit') || "BPM"}</span></div>`;
                            content += `<div class="chart-container"><canvas id="${canvasId}"></canvas></div>`;
                            const dataPoints = safeGet(metric, 'object.values');
                            const labels = dataPoints.map((_, index) => index);
                            setTimeout(() => createLineChart(canvasId, labels, dataPoints, safeGet(metric, 'object.title') || "Resting HR"), 0);
                        } else {
                            content += `<div class="metric-value">N/A <span class="metric-unit">BPM</span></div>`;
                        }
                        break;
                    // Glucose related metrics (assuming structure from initial doc)
                    case "glucose": // Assuming this might be an average or latest reading
                    case "metabolic_score":
                    case "glucose_variability":
                    case "average_glucose":
                    case "hba1c":
                    case "time_in_target":
                    case "vo2_max":
                        // Generic display - adjust if sample provides more structure
                        content += `<div class="metric-value">${safeGet(metric, 'object.value') ?? safeGet(metric, 'object.score') ?? safeGet(metric, 'object.avg') ?? "N/A"} <span class="metric-unit">${safeGet(metric, 'object.unit') || ""}</span></div>`;
                        if (safeGet(metric, 'object.title')) content += `<p class="metric-details">(${safeGet(metric, 'object.title')})</p>`;
                        break;
                    default:
                        content += `<p class="metric-details">Data structure not fully recognized for type: ${metric.type}</p>`;
                        content += `<pre>${JSON.stringify(metric.object, null, 2)}</pre>`; // Show raw data for unrecognized types
                }

                card.innerHTML = content;
                metricsDisplay.appendChild(card);
            });
        }

        function displayAggregatedMetrics(allMetricsData, dateRange) {
            try {
            metricsDisplay.innerHTML = ""; // Clear previous content
            
            // Group metrics by type
            const metricsByType = {};
            allMetricsData.forEach(metric => {
                if (!metricsByType[metric.type]) {
                    metricsByType[metric.type] = [];
                }
                metricsByType[metric.type].push(metric);
            });

            // Display aggregated data for each metric type
            Object.keys(metricsByType).forEach(metricType => {
                const metrics = metricsByType[metricType];
                const card = document.createElement("div");
                card.className = "metric-card";
                
                let content = `<h3>${metricType.replace("_", " ").toUpperCase()} (${dateRange.length} days)</h3>`;
                
                // Calculate aggregations based on metric type
                switch (metricType) {
                    case "sleep":
                    case "Sleep":
                        // Create separate sleep analytics cards for multi-day view
                        let totalTimeInBedSeconds = 0;
                        let totalActualSleepSeconds = 0;
                        let totalSleepEfficiency = 0;
                        let totalHR = 0;
                        let totalHRV = 0;
                        let validTimeInBedCount = 0;
                        let validActualSleepCount = 0;
                        let validEfficiencyCount = 0;
                        let validHRCount = 0;
                        let validHRVCount = 0;
                        let bedtimes = [];
                        let waketimes = [];

                        // Derived sleep metrics aggregation
                        let totalDeepSleepMin = 0, totalLightSleepMin = 0, totalRemSleepMin = 0, totalAwakeMin = 0;
                        let totalSolMin = 0, totalWasoMin = 0, totalWakeEpisodes = 0, totalTotalSleepDerivedMin = 0;
                        let validSleepGraphCount = 0;

                        metrics.forEach(m => {
                            const hasValidSleepData = safeGet(m, 'object.bedtime_start') && safeGet(m, 'object.bedtime_end');
                            if (hasValidSleepData) {
                                const timeInBedSeconds = safeGet(m, 'object.bedtime_end') - safeGet(m, 'object.bedtime_start');
                                totalTimeInBedSeconds += timeInBedSeconds;
                                validTimeInBedCount++;

                                // Collect bedtimes and wake times for consistency analysis
                                const bedtime = new Date(safeGet(m, 'object.bedtime_start') * 1000);
                                const waketime = new Date(safeGet(m, 'object.bedtime_end') * 1000);
                                bedtimes.push(bedtime.getHours() + bedtime.getMinutes() / 60);
                                waketimes.push(waketime.getHours() + waketime.getMinutes() / 60);
                            }

                            // Get total sleep from quick_metrics
                            const quickMetrics = safeGet(m, 'object.quick_metrics');
                            const totalSleepMetric = getQuickMetric(quickMetrics, 'total_sleep');
                            if (totalSleepMetric && totalSleepMetric.value) {
                                totalActualSleepSeconds += totalSleepMetric.value;
                                validActualSleepCount++;
                            }

                            // Get sleep efficiency from quick_metrics
                            const sleepEfficiencyMetric = getQuickMetric(quickMetrics, 'sleep_efic');
                            if (sleepEfficiencyMetric && sleepEfficiencyMetric.value !== null) {
                                totalSleepEfficiency += sleepEfficiencyMetric.value;
                                validEfficiencyCount++;
                            }

                            // Handle HR data from multiple possible locations
                            const hrFromGraph = safeGet(m.object, 'hr_graph.gist_object.avg');
                            const hrFromQuickMetrics = safeGet(m, 'object.quick_metrics')?.find(
                                metric => metric.type === 'avg_hr'
                            )?.value;
                            const hrValue = hrFromGraph || hrFromQuickMetrics;

                            if (hrValue) {
                                totalHR += hrValue;
                                validHRCount++;
                            }

                            // Handle HRV data from multiple possible locations
                            const hrvFromGraph = safeGet(m.object, 'hrv_graph.gist_object.avg');
                            const hrvFromQuickMetrics = safeGet(m, 'object.quick_metrics')?.find(
                                metric => metric.type === 'avg_hrv'
                            )?.value;
                            const hrvValue = hrvFromGraph || hrvFromQuickMetrics;

                            if (hrvValue) {
                                totalHRV += hrvValue;
                                validHRVCount++;
                            }

                            // Process derived sleep metrics from sleep_graph.data
                            const sleepGraphDataForAgg = processSleepGraphData(safeGet(m, 'object.sleep_graph.data'));
                            if (sleepGraphDataForAgg.hasData) {
                                totalDeepSleepMin += sleepGraphDataForAgg.deepSleepMin;
                                totalLightSleepMin += sleepGraphDataForAgg.lightSleepMin;
                                totalRemSleepMin += sleepGraphDataForAgg.remSleepMin;
                                totalAwakeMin += sleepGraphDataForAgg.awakeMin;
                                totalSolMin += sleepGraphDataForAgg.sleepOnsetLatencyMin;
                                totalWasoMin += sleepGraphDataForAgg.wasoMin;
                                totalWakeEpisodes += sleepGraphDataForAgg.wakeEpisodes;
                                totalTotalSleepDerivedMin += sleepGraphDataForAgg.totalSleepDerivedMin;
                                validSleepGraphCount++;
                            }
                        });

                        // Create main sleep summary card
                        content += `<div class="metric-value">${validTimeInBedCount}/${metrics.length} <span class="metric-unit">nights</span></div>`;
                        content += `<p class="metric-details">Nights with sleep data</p>`;
                        card.innerHTML = content;
                        metricsDisplay.appendChild(card);

                        // Create separate cards for each sleep metric
                        if (validTimeInBedCount > 0) {
                            // Average Time in Bed
                            const avgTimeInBedSeconds = totalTimeInBedSeconds / validTimeInBedCount;
                            const avgTimeInBed = formatDuration(avgTimeInBedSeconds);
                            const timeInBedCard = document.createElement("div");
                            timeInBedCard.className = "metric-card";
                            timeInBedCard.innerHTML = `
                                <h3>AVG TIME IN BED (${dateRange.length} days)</h3>
                                <div class="metric-value">${avgTimeInBed.formatted} <span class="metric-unit">(${avgTimeInBed.totalMinutes} min)</span></div>
                                <p class="metric-details">Average time from bedtime to wake</p>
                            `;
                            metricsDisplay.appendChild(timeInBedCard);
                        }

                        // Average Total Sleep - API value (if available)
                        if (validActualSleepCount > 0) {
                            const avgActualSleepSeconds = totalActualSleepSeconds / validActualSleepCount;
                            const avgActualSleep = formatDuration(avgActualSleepSeconds);
                            const actualSleepCard = document.createElement("div");
                            actualSleepCard.className = "metric-card";
                            actualSleepCard.innerHTML = `
                                <h3>AVG TOTAL SLEEP API (${dateRange.length} days)</h3>
                                <div class="metric-value">${avgActualSleep.formatted} <span class="metric-unit">(${avgActualSleep.totalMinutes} min)</span></div>
                                <p class="metric-details">From API quick_metrics</p>
                            `;
                            metricsDisplay.appendChild(actualSleepCard);
                        }

                        // Average Total Sleep - Derived (Deep + Light + REM)
                        if (validSleepGraphCount > 0) {
                            const avgDerivedSleepMin = Math.round(totalTotalSleepDerivedMin / validSleepGraphCount);
                            const derivedHours = Math.floor(avgDerivedSleepMin / 60);
                            const derivedMins = avgDerivedSleepMin % 60;
                            const derivedSleepCard = document.createElement("div");
                            derivedSleepCard.className = "metric-card";
                            derivedSleepCard.innerHTML = `
                                <h3>AVG TOTAL SLEEP DERIVED (${dateRange.length} days)</h3>
                                <div class="metric-value">${derivedHours}h ${derivedMins}m <span class="metric-unit">(${avgDerivedSleepMin} min)</span></div>
                                <p class="metric-details">Deep + Light + REM from segments</p>
                            `;
                            metricsDisplay.appendChild(derivedSleepCard);
                        }

                        // Average Sleep Efficiency (if available)
                        if (validEfficiencyCount > 0) {
                            const avgEfficiency = totalSleepEfficiency / validEfficiencyCount;
                            const efficiencyCard = document.createElement("div");
                            efficiencyCard.className = "metric-card";
                            efficiencyCard.innerHTML = `
                                <h3>AVG SLEEP EFFICIENCY (${dateRange.length} days)</h3>
                                <div class="metric-value">${avgEfficiency.toFixed(0)} <span class="metric-unit">%</span></div>
                                <p class="metric-details">Average sleep efficiency</p>
                            `;
                            metricsDisplay.appendChild(efficiencyCard);
                        }

                        // Average Bedtime
                        if (bedtimes.length > 0) {
                            const avgBedtime = calculateCircularMean(bedtimes, 'bedtime');
                            const bedtimeFormatted = formatTimeForDisplay(avgBedtime, 'bedtime');
                            const bedtimeCard = document.createElement("div");
                            bedtimeCard.className = "metric-card";
                            bedtimeCard.innerHTML = `
                                <h3>AVG BEDTIME (${dateRange.length} days)</h3>
                                <div class="metric-value">${bedtimeFormatted.displayTime.replace(' ', ' <span class="metric-unit">') + '</span>'}</div>
                                <p class="metric-details">Average sleep start time</p>
                            `;
                            metricsDisplay.appendChild(bedtimeCard);
                        }

                        // Average Wake Time
                        if (waketimes.length > 0) {
                            const avgWaketime = calculateCircularMean(waketimes, 'waketime');
                            const waketimeFormatted = formatTimeForDisplay(avgWaketime, 'waketime');
                            const waketimeCard = document.createElement("div");
                            waketimeCard.className = "metric-card";
                            waketimeCard.innerHTML = `
                                <h3>AVG WAKE TIME (${dateRange.length} days)</h3>
                                <div class="metric-value">${waketimeFormatted.displayTime.replace(' ', ' <span class="metric-unit">') + '</span>'}</div>
                                <p class="metric-details">Average wake up time</p>
                            `;
                            metricsDisplay.appendChild(waketimeCard);
                        }
                        
                        if (validHRCount > 0) {
                            const avgHR = totalHR / validHRCount;
                            const hrCard = document.createElement("div");
                            hrCard.className = "metric-card";
                            hrCard.innerHTML = `
                                <h3>AVG SLEEP HEART RATE (${dateRange.length} days)</h3>
                                <div class="metric-value">${avgHR.toFixed(0)} <span class="metric-unit">BPM</span></div>
                                <p class="metric-details">Average heart rate during sleep</p>
                            `;
                            metricsDisplay.appendChild(hrCard);
                        }
                        
                        if (validHRVCount > 0) {
                            const avgHRV = totalHRV / validHRVCount;
                            const hrvCard = document.createElement("div");
                            hrvCard.className = "metric-card";
                            hrvCard.innerHTML = `
                                <h3>AVG SLEEP HRV (${dateRange.length} days)</h3>
                                <div class="metric-value">${avgHRV.toFixed(0)} <span class="metric-unit">ms</span></div>
                                <p class="metric-details">Average HRV during sleep</p>
                            `;
                            metricsDisplay.appendChild(hrvCard);
                        }

                        // Derived Sleep Metrics Cards
                        if (validSleepGraphCount > 0) {
                            // Average Sleep Stages Card
                            const avgDeep = Math.round(totalDeepSleepMin / validSleepGraphCount);
                            const avgLight = Math.round(totalLightSleepMin / validSleepGraphCount);
                            const avgRem = Math.round(totalRemSleepMin / validSleepGraphCount);
                            const avgAwake = Math.round(totalAwakeMin / validSleepGraphCount);

                            const stagesCard = document.createElement("div");
                            stagesCard.className = "metric-card";
                            stagesCard.innerHTML = `
                                <h3>AVG SLEEP STAGES (${dateRange.length} days)</h3>
                                <div class="stages-grid">
                                    <div class="stage-item"><span class="stage-label">Deep</span><span class="stage-value">${avgDeep} min</span></div>
                                    <div class="stage-item"><span class="stage-label">Light</span><span class="stage-value">${avgLight} min</span></div>
                                    <div class="stage-item"><span class="stage-label">REM</span><span class="stage-value">${avgRem} min</span></div>
                                    <div class="stage-item"><span class="stage-label">Awake</span><span class="stage-value">${avgAwake} min</span></div>
                                </div>
                            `;
                            metricsDisplay.appendChild(stagesCard);

                            // Average Sleep Onset Latency Card
                            const avgSol = Math.round(totalSolMin / validSleepGraphCount);
                            const solCard = document.createElement("div");
                            solCard.className = "metric-card";
                            solCard.innerHTML = `
                                <h3>AVG SLEEP ONSET LATENCY (${dateRange.length} days)</h3>
                                <div class="metric-value">${avgSol} <span class="metric-unit">min</span></div>
                                <p class="metric-details">Average time from bedtime to first sleep</p>
                            `;
                            metricsDisplay.appendChild(solCard);

                            // Average WASO Card
                            const avgWaso = Math.round(totalWasoMin / validSleepGraphCount);
                            const wasoCard = document.createElement("div");
                            wasoCard.className = "metric-card";
                            wasoCard.innerHTML = `
                                <h3>AVG WASO (${dateRange.length} days)</h3>
                                <div class="metric-value">${avgWaso} <span class="metric-unit">min</span></div>
                                <p class="metric-details">Average Wake After Sleep Onset</p>
                            `;
                            metricsDisplay.appendChild(wasoCard);

                            // Average Wake Episodes Card
                            const avgWakeEp = (totalWakeEpisodes / validSleepGraphCount).toFixed(1);
                            const wakeEpisodesCard = document.createElement("div");
                            wakeEpisodesCard.className = "metric-card";
                            wakeEpisodesCard.innerHTML = `
                                <h3>AVG WAKE EPISODES (${dateRange.length} days)</h3>
                                <div class="metric-value">${avgWakeEp} <span class="metric-unit">per night</span></div>
                                <p class="metric-details">Average awakenings during sleep</p>
                            `;
                            metricsDisplay.appendChild(wakeEpisodesCard);

                        }

                        // Skip normal card creation since we created multiple cards
                        return;
                        break;
                    case "hr":
                    case "temp":
                    case "hrv":
                    case "night_rhr":
                        // Filter out invalid metrics and safely extract values
                        const validMetrics = metrics.filter(m => m && m.object);
                        const avgValue = validMetrics.reduce((sum, m) => {
                            const avg = safeGet(m, 'object.avg', 0);
                            const lastReading = safeGet(m, 'object.last_reading', 0);
                            const value = safeGet(m, 'object.value', 0);
                            return sum + (avg || lastReading || value || 0);
                        }, 0) / (validMetrics.length || 1);
                        
                        const unit = safeGet(validMetrics[0], 'object.unit', '') || (metricType === "hrv" ? "ms" : "");
                        content += `<div class="metric-value">${avgValue.toFixed(1)} <span class="metric-unit">${unit} (Avg)</span></div>`;
                        
                        // Show range if available - use safe extraction
                        const hrValues = validMetrics.map(m => {
                            const avg = safeGet(m, 'object.avg', 0);
                            const lastReading = safeGet(m, 'object.last_reading', 0);
                            const value = safeGet(m, 'object.value', 0);
                            return avg || lastReading || value || 0;
                        }).filter(v => v > 0);
                        if (hrValues.length > 0) {
                            const minVal = Math.min(...hrValues);
                            const maxVal = Math.max(...hrValues);
                            content += `<p class="metric-details">Range: ${minVal.toFixed(1)} - ${maxVal.toFixed(1)} ${unit}</p>`;
                        }
                        break;
                    case "steps":
                        const validStepsMetrics = metrics.filter(m => m && m.object);
                        // Use total (full day count) as primary for each day
                        const totalSteps = validStepsMetrics.reduce((sum, m) => {
                            return sum + (safeGet(m, 'object.total') || safeGet(m, 'object.avg') || safeGet(m, 'object.value') || 0);
                        }, 0);
                        const avgSteps = totalSteps / (validStepsMetrics.length || 1);
                        content += `<div class="metric-value">${totalSteps.toFixed(0)} <span class="metric-unit">Total Steps</span></div>`;
                        content += `<p class="metric-details">Daily Average: ${avgSteps.toFixed(0)} steps (calendar day)</p>`;
                        break;
                    case "avg_sleep_hrv":
                        const validHrvMetrics = metrics.filter(m => m && m.object);
                        const avgSleepHrv = validHrvMetrics.reduce((sum, m) => {
                            return sum + (safeGet(m, 'object.value') || safeGet(m, 'object.avg') || 0);
                        }, 0) / (validHrvMetrics.length || 1);
                        content += `<div class="metric-value">${avgSleepHrv.toFixed(0)} <span class="metric-unit">ms (Avg)</span></div>`;
                        break;
                    case "recovery_index":
                    case "movement_index":
                        const avgIndex = metrics.reduce((sum, m) => sum + (safeGet(m, 'object.value') || 0), 0) / metrics.length;
                        content += `<div class="metric-value">${avgIndex.toFixed(0)} <span class="metric-unit">Index (Avg)</span></div>`;
                        break;
                    case "active_minutes":
                        const totalMinutes = metrics.reduce((sum, m) => sum + (safeGet(m, 'object.value') || 0), 0);
                        const avgMinutes = totalMinutes / metrics.length;
                        content += `<div class="metric-value">${totalMinutes} <span class="metric-unit">Total Minutes</span></div>`;
                        content += `<p class="metric-details">Daily Average: ${avgMinutes.toFixed(0)} minutes</p>`;
                        break;
                    case "sleep_rhr":
                        const avgSleepRhr = metrics.reduce((sum, m) => sum + (safeGet(m, 'object.value') || 0), 0) / metrics.length;
                        content += `<div class="metric-value">${avgSleepRhr.toFixed(0)} <span class="metric-unit">BPM (Avg)</span></div>`;
                        break;
                    case "vo2_max":
                        const avgVo2 = metrics.reduce((sum, m) => sum + (safeGet(m, 'object.value') || 0), 0) / metrics.length;
                        content += `<div class="metric-value">${avgVo2.toFixed(0)} <span class="metric-unit">ml/kg/min (Avg)</span></div>`;
                        break;
                    case "glucose":
                    case "metabolic_score":
                    case "glucose_variability":
                    case "average_glucose":
                    case "hba1c":
                    case "time_in_target":
                        const glucoseValues = metrics.map(m => safeGet(m, 'object.value') || 0).filter(v => v > 0);
                        if (glucoseValues.length > 0) {
                            const avgVal = glucoseValues.reduce((sum, v) => sum + v, 0) / glucoseValues.length;
                            const unitStr = metricType.includes("score") ? "Score" : metricType.includes("variability") || metricType.includes("target") ? "%" : "mg/dL";
                            content += `<div class="metric-value">${avgVal.toFixed(1)} <span class="metric-unit">${unitStr} (Avg)</span></div>`;
                        } else {
                            content += `<p class="metric-details">No data available</p>`;
                        }
                        break;
                    default:
                        // For unrecognized types, try to show value if available
                        const genericValues = metrics.map(m => safeGet(m, 'object.value') || 0).filter(v => v > 0);
                        if (genericValues.length > 0) {
                            const avg = genericValues.reduce((sum, v) => sum + v, 0) / genericValues.length;
                            content += `<div class="metric-value">${avg.toFixed(1)} <span class="metric-unit">(Avg)</span></div>`;
                        } else {
                            content += `<p class="metric-details">${metrics.length} data points collected</p>`;
                        }
                }
                
                // Add date range info
                content += `<p class="metric-details">Period: ${dateRange[0]} to ${dateRange[dateRange.length - 1]}</p>`;
                
                card.innerHTML = content;
                metricsDisplay.appendChild(card);
            });
            } catch (error) {
                console.error("Error displaying aggregated metrics:", error);
                // Display partial results if possible
                if (metricsDisplay.innerHTML === "") {
                    metricsDisplay.innerHTML = `<div class="error">Unable to display some metrics due to data format issues. This may occur for users with different device models or limited data availability.</div>`;
                }
                // Re-throw to be caught by the parent try-catch
                throw error;
            }
        }

        function exportToCSV() {
            if (!currentMetricsData || currentMetricsData.length === 0) {
                displayError(dashboardError, "No data available to export.");
                return;
            }

            // Get selected user info
            const selectedUserId = userSelect.value;
            const selectedUserText = userSelect.options[userSelect.selectedIndex].text;
            const userEmail = selectedUserText.split(' (ID:')[0]; // Extract email from "email (ID: X)" format
            
            // Check selected format
            const formatSelection = document.querySelector('input[name="single-csv-format"]:checked');
            const exportFormat = formatSelection ? formatSelection.value : 'long';
            
            // Add userEmail to metrics data for wide format
            const metricsWithUser = currentMetricsData.map(metric => ({
                ...metric,
                userEmail: userEmail
            }));
            
            if (exportFormat === 'wide') {
                // Use wide format export
                const startDate = singleDateMode.checked ? dateSelect.value : startDateSelect.value;
                const endDate = singleDateMode.checked ? dateSelect.value : endDateSelect.value;
                exportWideFormatCSV(metricsWithUser, startDate, endDate, 'ultrahuman_data');
                return;
            }

            // Continue with existing long format logic
            // Prepare CSV data
            const csvRows = [];
            const headers = ["User Email", "Date", "Metric Type", "Value", "Unit", "Details"];
            csvRows.push(headers.join(","));

            currentMetricsData.forEach(metric => {
                const date = metric.date || "N/A";
                const type = metric.type || "N/A";

                // Handle sleep metrics by creating multiple CSV rows for each sleep component
                if (metric.type === "sleep" || metric.type === "Sleep") {
                    const hasAnyData = Object.keys(metric.object).length > 0;
                    const hasFullSleepData = safeGet(metric, 'object.bedtime_start') && safeGet(metric, 'object.bedtime_end');
                    
                    if (hasFullSleepData) {
                        const bedtimeStart = new Date(safeGet(metric, 'object.bedtime_start') * 1000);
                        const bedtimeEnd = new Date(safeGet(metric, 'object.bedtime_end') * 1000);
                        const timeInBedSeconds = safeGet(metric, 'object.bedtime_end') - safeGet(metric, 'object.bedtime_start');
                        const timeInBed = formatDuration(timeInBedSeconds);

                        // Get total sleep and efficiency from quick_metrics
                        const quickMetrics = safeGet(metric, 'object.quick_metrics');
                        const totalSleepMetric = getQuickMetric(quickMetrics, 'total_sleep');
                        const sleepEfficiencyMetric = getQuickMetric(quickMetrics, 'sleep_efic');
                        const totalSleep = totalSleepMetric ? formatDuration(totalSleepMetric.value) : null;
                        const sleepEfficiency = sleepEfficiencyMetric ? sleepEfficiencyMetric.value : null;

                        // Bedtime
                        csvRows.push([
                            userEmail,
                            date,
                            "Bedtime",
                            bedtimeStart.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }),
                            "Time",
                            "Sleep start time"
                        ].join(","));

                        // Wake time
                        csvRows.push([
                            userEmail,
                            date,
                            "Wake Time",
                            bedtimeEnd.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }),
                            "Time",
                            "Sleep end time"
                        ].join(","));

                        // Bedtime Date
                        csvRows.push([
                            userEmail,
                            date,
                            "Bedtime Date",
                            bedtimeStart.toLocaleDateString('en-CA'),
                            "Date",
                            "Calendar date of bedtime"
                        ].join(","));

                        // Wake Date
                        csvRows.push([
                            userEmail,
                            date,
                            "Wake Date",
                            bedtimeEnd.toLocaleDateString('en-CA'),
                            "Date",
                            "Calendar date of wake time"
                        ].join(","));

                        // Bedtime Unix Timestamp
                        csvRows.push([
                            userEmail,
                            date,
                            "Bedtime Unix",
                            safeGet(metric, 'object.bedtime_start'),
                            "Unix",
                            "Unix timestamp of bedtime (seconds)"
                        ].join(","));

                        // Wake Unix Timestamp
                        csvRows.push([
                            userEmail,
                            date,
                            "Wake Unix",
                            safeGet(metric, 'object.bedtime_end'),
                            "Unix",
                            "Unix timestamp of wake time (seconds)"
                        ].join(","));

                        // Time in Bed (formatted)
                        csvRows.push([
                            userEmail,
                            date,
                            "Time in Bed",
                            timeInBed.formatted,
                            "hours/min",
                            "From bedtime to wake time"
                        ].join(","));

                        // Time in Bed (minutes)
                        csvRows.push([
                            userEmail,
                            date,
                            "Time in Bed (Minutes)",
                            timeInBed.totalMinutes,
                            "min",
                            "Time in bed in minutes"
                        ].join(","));

                        // Total Sleep - API value (if available)
                        if (totalSleep) {
                            csvRows.push([
                                userEmail,
                                date,
                                "Total Sleep (API)",
                                totalSleep.formatted,
                                "hours/min",
                                "From API quick_metrics"
                            ].join(","));

                            csvRows.push([
                                userEmail,
                                date,
                                "Total Sleep API (Minutes)",
                                totalSleep.totalMinutes,
                                "min",
                                "From API quick_metrics in minutes"
                            ].join(","));
                        }

                        // Sleep Efficiency (if available)
                        if (sleepEfficiency !== null) {
                            csvRows.push([
                                userEmail,
                                date,
                                "Sleep Efficiency",
                                sleepEfficiency,
                                "%",
                                "Total sleep / Time in bed"
                            ].join(","));
                        }
                        
                        // Sleep heart rate metrics
                        if (safeGet(metric, 'object.hr_graph') && safeGet(metric, 'object.hr_graph.gist_object')) {
                            const hrGist = safeGet(metric, 'object.hr_graph.gist_object');
                            csvRows.push([
                                userEmail,
                                date,
                                "Sleep Heart Rate (Lowest)",
                                hrGist.detail_text || hrGist.min || "N/A",
                                "BPM",
                                hrGist.title || "Lowest heart rate during sleep"
                            ].join(","));
                            
                            if (hrGist.avg) {
                                csvRows.push([
                                    userEmail,
                                    date,
                                    "Sleep Heart Rate (Average)",
                                    hrGist.avg,
                                    "BPM",
                                    "Average heart rate during sleep"
                                ].join(","));
                            }
                        }
                        
                        // Sleep HRV metrics
                        if (safeGet(metric, 'object.hrv_graph') && safeGet(metric, 'object.hrv_graph.gist_object')) {
                            const hrvGist = safeGet(metric, 'object.hrv_graph.gist_object');
                            csvRows.push([
                                userEmail,
                                date,
                                "Sleep HRV Zone",
                                hrvGist.detail_text || "N/A",
                                "ms",
                                hrvGist.title || "HRV zone during sleep"
                            ].join(","));
                            
                            if (hrvGist.avg) {
                                csvRows.push([
                                    userEmail,
                                    date,
                                    "Sleep HRV (Average)",
                                    hrvGist.avg,
                                    "ms",
                                    "Average HRV during sleep"
                                ].join(","));
                            }
                        }

                        // Derived sleep metrics from sleep_graph.data
                        const sleepGraphDataCSV = processSleepGraphData(safeGet(metric, 'object.sleep_graph.data'));
                        if (sleepGraphDataCSV.hasData) {
                            // Sleep stage durations
                            csvRows.push([
                                userEmail,
                                date,
                                "Deep Sleep",
                                sleepGraphDataCSV.deepSleepMin,
                                "min",
                                "Deep sleep duration"
                            ].join(","));

                            csvRows.push([
                                userEmail,
                                date,
                                "Light Sleep",
                                sleepGraphDataCSV.lightSleepMin,
                                "min",
                                "Light sleep duration"
                            ].join(","));

                            csvRows.push([
                                userEmail,
                                date,
                                "REM Sleep",
                                sleepGraphDataCSV.remSleepMin,
                                "min",
                                "REM sleep duration"
                            ].join(","));

                            csvRows.push([
                                userEmail,
                                date,
                                "Awake Time",
                                sleepGraphDataCSV.awakeMin,
                                "min",
                                "Total awake time during sleep period"
                            ].join(","));

                            // Derived metrics
                            csvRows.push([
                                userEmail,
                                date,
                                "Sleep Onset Latency",
                                sleepGraphDataCSV.sleepOnsetLatencyMin,
                                "min",
                                "Time from bedtime to first sleep"
                            ].join(","));

                            csvRows.push([
                                userEmail,
                                date,
                                "WASO",
                                sleepGraphDataCSV.wasoMin,
                                "min",
                                "Wake After Sleep Onset"
                            ].join(","));

                            csvRows.push([
                                userEmail,
                                date,
                                "Wake Episodes",
                                sleepGraphDataCSV.wakeEpisodes,
                                "count",
                                "Number of awakenings during sleep"
                            ].join(","));

                            // Total Sleep (Derived) - Deep + Light + REM
                            const derivedHours = Math.floor(sleepGraphDataCSV.totalSleepDerivedMin / 60);
                            const derivedMins = sleepGraphDataCSV.totalSleepDerivedMin % 60;
                            csvRows.push([
                                userEmail,
                                date,
                                "Total Sleep (Derived)",
                                `${derivedHours}h ${derivedMins}m`,
                                "hours/min",
                                "Deep + Light + REM from segments"
                            ].join(","));

                            csvRows.push([
                                userEmail,
                                date,
                                "Total Sleep Derived (Minutes)",
                                sleepGraphDataCSV.totalSleepDerivedMin,
                                "min",
                                "Deep + Light + REM from segments in minutes"
                            ].join(","));

                        }
                    } else if (!hasAnyData) {
                        // Handle empty Sleep objects - no data available
                        csvRows.push([
                            userEmail,
                            date,
                            "Sleep Status",
                            "No Data Available",
                            "Status",
                            "No sleep data recorded for this date"
                        ].join(","));
                    } else {
                        // Fallback for other sleep data formats (score-based, etc.)
                        csvRows.push([
                            userEmail,
                            date,
                            type,
                            safeGet(metric, 'object.score') || safeGet(metric, 'object.value') || "N/A",
                            "Score",
                            safeGet(metric, 'object.subtitle') || ""
                        ].join(","));
                    }
                } else {
                    // Handle non-sleep metrics with original logic
                    let value = "N/A";
                    let unit = "";
                    let details = "";

                    switch (metric.type) {
                    case "hr":
                    case "heart_rate":
                        value = safeGet(metric, 'object.avg') || safeGet(metric, 'object.last_reading') || safeGet(metric, 'object.value') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "BPM";
                        details = safeGet(metric, 'object.subtitle') || safeGet(metric, 'object.title') || "";
                        break;
                    case "temp":
                    case "temperature":
                        value = safeGet(metric, 'object.avg') || safeGet(metric, 'object.last_reading') || safeGet(metric, 'object.value') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "C";
                        details = safeGet(metric, 'object.subtitle') || safeGet(metric, 'object.title') || "";
                        break;
                    case "hrv":
                    case "heart_rate_variability":
                        value = safeGet(metric, 'object.avg') || safeGet(metric, 'object.last_reading') || safeGet(metric, 'object.value') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "ms";
                        details = safeGet(metric, 'object.subtitle') || safeGet(metric, 'object.title') || "";
                        break;
                    case "night_rhr":
                    case "resting_heart_rate":
                        value = safeGet(metric, 'object.avg') || safeGet(metric, 'object.last_reading') || safeGet(metric, 'object.value') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "BPM";
                        details = safeGet(metric, 'object.subtitle') || safeGet(metric, 'object.title') || "Sleep Time Average";
                        break;
                    case "avg_sleep_hrv":
                        value = safeGet(metric, 'object.avg') || safeGet(metric, 'object.value') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "ms";
                        details = "Average Sleep HRV";
                        break;
                    case "steps":
                        // Use total (full day count) as primary
                        value = safeGet(metric, 'object.total') || safeGet(metric, 'object.avg') || safeGet(metric, 'object.value') || "N/A";
                        unit = "Steps";
                        details = "Daily total (calendar day)";
                        break;
                    case "glucose":
                        // Handle glucose with values array or direct value
                        if (safeGet(metric, 'object.values') && safeGet(metric, 'object.values').length > 0) {
                            // Calculate average from values array
                            const values = safeGet(metric, 'object.values');
                            const avgGlucose = values.reduce((sum, v) => sum + (v.value || v || 0), 0) / values.length;
                            value = avgGlucose.toFixed(1);
                        } else {
                            value = safeGet(metric, 'object.avg') || safeGet(metric, 'object.value') || safeGet(metric, 'object.last_reading') || "N/A";
                        }
                        unit = safeGet(metric, 'object.unit') || "mg/dL";
                        details = safeGet(metric, 'object.title') || "Glucose";
                        break;
                    case "metabolic_score":
                        value = safeGet(metric, 'object.score') || safeGet(metric, 'object.value') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "Score";
                        details = "Metabolic Score";
                        break;
                    case "glucose_variability":
                        value = safeGet(metric, 'object.percentage') || safeGet(metric, 'object.value') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "%";
                        details = "Glucose Variability";
                        break;
                    case "average_glucose":
                        value = safeGet(metric, 'object.avg') || safeGet(metric, 'object.value') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "mg/dL";
                        details = "Average Glucose";
                        break;
                    case "hba1c":
                        value = safeGet(metric, 'object.value') || safeGet(metric, 'object.percentage') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "%";
                        details = "HbA1c";
                        break;
                    case "time_in_target":
                        value = safeGet(metric, 'object.percentage') || safeGet(metric, 'object.value') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "%";
                        details = "Time in Target";
                        break;
                    case "recovery_index":
                        value = safeGet(metric, 'object.value') || safeGet(metric, 'object.score') || safeGet(metric, 'object.index') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "Index";
                        details = safeGet(metric, 'object.title') || "Recovery Index";
                        break;
                    case "movement_index":
                        value = safeGet(metric, 'object.value') || safeGet(metric, 'object.score') || safeGet(metric, 'object.index') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "Index";
                        details = safeGet(metric, 'object.title') || "Movement Index";
                        break;
                    case "active_minutes":
                        value = safeGet(metric, 'object.value') || safeGet(metric, 'object.total') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "Minutes";
                        details = safeGet(metric, 'object.title') || "Active Minutes";
                        break;
                    case "vo2_max":
                        value = safeGet(metric, 'object.value') || safeGet(metric, 'object.score') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "ml/kg/min";
                        details = "VO2 Max";
                        break;
                    case "sleep_rhr":
                        value = safeGet(metric, 'object.value') || safeGet(metric, 'object.avg') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "BPM";
                        details = "Sleep Resting Heart Rate";
                        break;
                    case "avg_sleep_hrv":
                        value = safeGet(metric, 'object.value') || "N/A";
                        unit = "ms";
                        details = "Average Sleep HRV";
                        break;
                    default:
                        // Generic fallback for unknown metric types
                        value = safeGet(metric, 'object.value') || safeGet(metric, 'object.score') || safeGet(metric, 'object.avg') || 
                               safeGet(metric, 'object.total') || safeGet(metric, 'object.percentage') || safeGet(metric, 'object.index') || 
                               safeGet(metric, 'object.last_reading') || "N/A";
                        unit = safeGet(metric, 'object.unit') || "";
                        details = safeGet(metric, 'object.title') || safeGet(metric, 'object.subtitle') || safeGet(metric, 'object.description') || "";
                    }

                    // Add CSV row for non-sleep metrics
                    // Escape commas and quotes in CSV data
                    const escapeCsvField = (field) => {
                        if (typeof field === "string" && (field.includes(",") || field.includes('"'))) {
                            return `"${field.replace(/"/g, '""')}"`;
                        }
                        return field;
                    };

                    csvRows.push([
                        escapeCsvField(userEmail),
                        escapeCsvField(date),
                        escapeCsvField(type),
                        escapeCsvField(value),
                        escapeCsvField(unit),
                        escapeCsvField(details)
                    ].join(","));
                }
            });

            // Continue with the rest of the CSV export function
            const csvContent = csvRows.join("\n");
            const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
            const url = URL.createObjectURL(blob);

            // Create download link
            const downloadLink = document.createElement("a");
            downloadLink.href = url;
            const dateStr = singleDateMode.checked ? dateSelect.value : `${startDateSelect.value}_to_${endDateSelect.value}`;
            downloadLink.download = `ultrahuman_data_${dateStr}.csv`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(url);
        }

        // --- Charting Functions ---
        function destroyCharts() {
            Object.values(currentChartInstances).forEach(chart => chart.destroy());
            currentChartInstances = {};
        }

        function createLineChart(canvasId, labels, data, label) {
            const ctx = document.getElementById(canvasId)?.getContext("2d");
            if (!ctx) return;
            currentChartInstances[canvasId] = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: data,
                        borderColor: "#007bff",
                        tension: 0.1,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            type: "time",
                            time: {
                                unit: "hour",
                                displayFormats: { hour: "HH:mm" }
                            },
                            title: { display: true, text: "Time" }
                        },
                        y: {
                            beginAtZero: false,
                            title: { display: true, text: "Value" }
                        }
                    }
                }
            });
        }

        function createDoughnutChart(canvasId, labels, data) {
            const ctx = document.getElementById(canvasId)?.getContext("2d");
            if (!ctx) return;
            currentChartInstances[canvasId] = new Chart(ctx, {
                type: "doughnut",
                data: {
                    labels: labels,
                    datasets: [{
                        label: "Sleep Stages",
                        data: data,
                        backgroundColor: [
                            "#0d6efd", // Deep
                            "#6c757d", // Light
                            "#198754", // REM
                            "#ffc107"  // Awake
                        ],
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || "";
                                    if (label) {
                                        label += ": ";
                                    }
                                    if (context.parsed !== null) {
                                        label += context.parsed.toFixed(2) + "%";
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        // --- Time Averaging Utilities ---
        /**
         * Calculate circular mean for time values that may cross midnight
         * @param {number[]} times - Array of time values in decimal hours (0-24)
         * @param {string} timeType - 'bedtime' or 'waketime' for context-specific logic
         * @returns {number} - Circular mean in decimal hours
         */
        function calculateCircularMean(times, timeType = 'bedtime') {
            if (!times || times.length === 0) return 0;
            if (times.length === 1) return times[0];
            
            // Check if we need circular averaging by detecting midnight boundary crossing
            if (!needsCircularAveraging(times, timeType)) {
                // Use simple arithmetic mean if no midnight crossing detected
                return times.reduce((sum, time) => sum + time, 0) / times.length;
            }
            
            // Convert times to radians (0-24 hours  0-2 radians)
            let sinSum = 0;
            let cosSum = 0;
            
            times.forEach(time => {
                const angleRad = (time * 2 * Math.PI) / 24;
                sinSum += Math.sin(angleRad);
                cosSum += Math.cos(angleRad);
            });
            
            // Calculate mean angle
            const meanAngleRad = Math.atan2(sinSum, cosSum);
            
            // Convert back to hours (ensure positive result)
            let meanTime = (meanAngleRad * 24) / (2 * Math.PI);
            if (meanTime < 0) meanTime += 24;
            
            return meanTime;
        }
        
        /**
         * Detect if times cross midnight boundary and need circular averaging
         * @param {number[]} times - Array of time values in decimal hours
         * @param {string} timeType - 'bedtime' or 'waketime' for context-specific logic
         * @returns {boolean} - True if circular averaging is needed
         */
        function needsCircularAveraging(times, timeType) {
            if (times.length < 2) return false;
            
            const min = Math.min(...times);
            const max = Math.max(...times);
            
            if (timeType === 'bedtime') {
                // For bedtimes, check if we have times both before and after midnight
                // Typical bedtime range: 9 PM (21) to 3 AM (3)
                // If we have times < 6 (early morning) and times > 18 (evening), likely crossing midnight
                return (min < 6 && max > 18);
            } else if (timeType === 'waketime') {
                // For wake times, less likely to cross midnight but possible for shift workers
                // Typical wake time range: 5 AM (5) to 11 AM (11)
                // If we have times < 6 (very early) and times > 18 (evening), likely crossing
                return (min < 6 && max > 18);
            }
            
            return false;
        }
        
        /**
         * Format time for display with proper AM/PM logic
         * @param {number} timeDecimal - Time in decimal hours (0-24)
         * @param {string} timeType - 'bedtime' or 'waketime' for context
         * @returns {object} - {hour, minute, period, displayTime}
         */
        function formatTimeForDisplay(timeDecimal, timeType) {
            let hour = Math.floor(timeDecimal);
            const minute = Math.round((timeDecimal - hour) * 60);
            
            // Handle minute overflow
            if (minute >= 60) {
                hour += 1;
                if (hour >= 24) hour = 0;
            }
            
            let period, displayHour;
            
            if (hour === 0) {
                displayHour = 12;
                period = 'AM';
            } else if (hour < 12) {
                displayHour = hour;
                period = 'AM';
            } else if (hour === 12) {
                displayHour = 12;
                period = 'PM';
            } else {
                displayHour = hour - 12;
                period = 'PM';
            }
            
            const formattedMinute = Math.max(0, Math.min(59, minute)).toString().padStart(2, '0');
            const displayTime = `${displayHour}:${formattedMinute} ${period}`;
            
            return {
                hour: displayHour,
                minute: Math.max(0, Math.min(59, minute)),
                period,
                displayTime
            };
        }

        // --- Tab Navigation Functions ---
        function switchTab(tabName) {
            // Remove active class from all tabs and content
            const tabs = document.querySelectorAll('.tab-button');
            const contents = document.querySelectorAll('.tab-content');
            
            tabs.forEach(tab => tab.classList.remove('active'));
            contents.forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            // If switching to multi-export tab, populate user checkboxes
            if (tabName === 'multi-export') {
                populateUserCheckboxes();
                setMultiExportDates();
            }
        }
        
        // Make switchTab global
        window.switchTab = switchTab;
        
        // --- Multi-User Export Functions ---
        function populateUserCheckboxes() {
            const userCheckboxesDiv = document.getElementById('user-checkboxes');
            userCheckboxesDiv.innerHTML = '';
            
            // Get users from the API
            fetch(userApiUrl)
                .then(response => response.json())
                .then(users => {
                    users.forEach(user => {
                        const checkboxItem = document.createElement('div');
                        checkboxItem.className = 'user-checkbox-item';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = `user-checkbox-${user.id}`;
                        checkbox.value = user.id;
                        
                        const label = document.createElement('label');
                        label.htmlFor = `user-checkbox-${user.id}`;
                        label.textContent = `${user.email} (ID: ${user.id})`;
                        
                        checkboxItem.appendChild(checkbox);
                        checkboxItem.appendChild(label);
                        userCheckboxesDiv.appendChild(checkboxItem);
                    });
                })
                .catch(error => {
                    console.error('Error fetching users for checkboxes:', error);
                    userCheckboxesDiv.innerHTML = '<p style="color: #ef4444;">Error loading users</p>';
                });
        }
        
        // Set today's date for multi-user export
        function setMultiExportDates() {
            const today = new Date().toISOString().split("T")[0];
            document.getElementById('multi-start-date').value = today;
            document.getElementById('multi-end-date').value = today;
        }
        
        // --- Wide Format Export Functions ---
        /**
         * Export data in wide format where each row represents one user-date combination
         * @param {Array} metricsData - Array of metric data with userEmail and date properties
         * @param {string} startDate - Start date for filename
         * @param {string} endDate - End date for filename  
         * @param {string} filePrefix - Prefix for filename (e.g., 'ultrahuman_data' or 'ultrahuman_multi_user_data')
         */
        function exportWideFormatCSV(metricsData, startDate, endDate, filePrefix = 'ultrahuman_data') {
            // Group data by user email and date
            const groupedData = {};
            
            metricsData.forEach(metric => {
                const userEmail = metric.userEmail || "N/A";
                const date = metric.date || "N/A";
                const key = `${userEmail}|${date}`;
                
                if (!groupedData[key]) {
                    groupedData[key] = {
                        userEmail: userEmail,
                        date: date,
                        metrics: {}
                    };
                }
                
                // Process different metric types
                if (metric.type === "sleep" || metric.type === "Sleep") {
                    const hasFullSleepData = safeGet(metric, 'object.bedtime_start') && safeGet(metric, 'object.bedtime_end');

                    if (hasFullSleepData) {
                        const bedtimeStart = new Date(safeGet(metric, 'object.bedtime_start') * 1000);
                        const bedtimeEnd = new Date(safeGet(metric, 'object.bedtime_end') * 1000);
                        const timeInBedSeconds = safeGet(metric, 'object.bedtime_end') - safeGet(metric, 'object.bedtime_start');
                        const timeInBed = formatDuration(timeInBedSeconds);

                        // Get total sleep and efficiency from quick_metrics
                        const quickMetrics = safeGet(metric, 'object.quick_metrics');
                        const totalSleepMetric = getQuickMetric(quickMetrics, 'total_sleep');
                        const sleepEfficiencyMetric = getQuickMetric(quickMetrics, 'sleep_efic');
                        const totalSleep = totalSleepMetric ? formatDuration(totalSleepMetric.value) : null;
                        const sleepEfficiency = sleepEfficiencyMetric ? sleepEfficiencyMetric.value : null;

                        groupedData[key].metrics['Bedtime'] = bedtimeStart.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
                        groupedData[key].metrics['Bedtime_Date'] = bedtimeStart.toLocaleDateString('en-CA'); // YYYY-MM-DD format in local timezone
                        groupedData[key].metrics['Bedtime_Unix'] = safeGet(metric, 'object.bedtime_start');
                        groupedData[key].metrics['Wake_Time'] = bedtimeEnd.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
                        groupedData[key].metrics['Wake_Date'] = bedtimeEnd.toLocaleDateString('en-CA'); // YYYY-MM-DD format in local timezone
                        groupedData[key].metrics['Wake_Unix'] = safeGet(metric, 'object.bedtime_end');
                        groupedData[key].metrics['Time_In_Bed_HM'] = timeInBed.formatted;
                        groupedData[key].metrics['Time_In_Bed_Min'] = timeInBed.totalMinutes;

                        // Total Sleep - API value (if available)
                        if (totalSleep) {
                            groupedData[key].metrics['Total_Sleep_API_HM'] = totalSleep.formatted;
                            groupedData[key].metrics['Total_Sleep_API_Min'] = totalSleep.totalMinutes;
                        }

                        // Sleep Efficiency (if available)
                        if (sleepEfficiency !== null) {
                            groupedData[key].metrics['Sleep_Efficiency_Pct'] = sleepEfficiency;
                        }

                        // Sleep Heart Rate
                        if (safeGet(metric, 'object.hr_graph.gist_object.avg')) {
                            groupedData[key].metrics['Sleep_HR_Avg_BPM'] = safeGet(metric, 'object.hr_graph.gist_object.avg');
                            groupedData[key].metrics['Sleep_HR_Min_BPM'] = safeGet(metric, 'object.hr_graph.gist_object.min', 'N/A');
                            groupedData[key].metrics['Sleep_HR_Max_BPM'] = safeGet(metric, 'object.hr_graph.gist_object.max', 'N/A');
                        }

                        // Sleep HRV
                        if (safeGet(metric, 'object.hrv_graph.gist_object.avg')) {
                            groupedData[key].metrics['Sleep_HRV_Avg_MS'] = safeGet(metric, 'object.hrv_graph.gist_object.avg');
                            groupedData[key].metrics['Sleep_HRV_Min_MS'] = safeGet(metric, 'object.hrv_graph.gist_object.min', 'N/A');
                            groupedData[key].metrics['Sleep_HRV_Max_MS'] = safeGet(metric, 'object.hrv_graph.gist_object.max', 'N/A');
                        }

                        // Derived sleep metrics from sleep_graph.data
                        const sleepGraphDataWide = processSleepGraphData(safeGet(metric, 'object.sleep_graph.data'));
                        if (sleepGraphDataWide.hasData) {
                            groupedData[key].metrics['Deep_Sleep_Min'] = sleepGraphDataWide.deepSleepMin;
                            groupedData[key].metrics['Light_Sleep_Min'] = sleepGraphDataWide.lightSleepMin;
                            groupedData[key].metrics['REM_Sleep_Min'] = sleepGraphDataWide.remSleepMin;
                            groupedData[key].metrics['Awake_Min'] = sleepGraphDataWide.awakeMin;
                            groupedData[key].metrics['Sleep_Onset_Latency_Min'] = sleepGraphDataWide.sleepOnsetLatencyMin;
                            groupedData[key].metrics['WASO_Min'] = sleepGraphDataWide.wasoMin;
                            groupedData[key].metrics['Wake_Episodes'] = sleepGraphDataWide.wakeEpisodes;
                            // Total Sleep - Derived (Deep + Light + REM)
                            const derivedHours = Math.floor(sleepGraphDataWide.totalSleepDerivedMin / 60);
                            const derivedMins = sleepGraphDataWide.totalSleepDerivedMin % 60;
                            groupedData[key].metrics['Total_Sleep_Derived_HM'] = `${derivedHours}h ${derivedMins}m`;
                            groupedData[key].metrics['Total_Sleep_Derived_Min'] = sleepGraphDataWide.totalSleepDerivedMin;
                        }
                    }
                } else if (metric.type === "steps") {
                    // Handle steps separately to ensure proper column naming
                    // Use total (full day count) as primary for steps
                    const stepsValue = safeGet(metric, 'object.total') || safeGet(metric, 'object.avg') || safeGet(metric, 'object.value') || 'N/A';
                    groupedData[key].metrics['Steps_Daily'] = stepsValue;
                } else if (metric.type === "temp" || metric.type === "temperature") {
                    // Handle temperature with proper fallback chain
                    const tempValue = safeGet(metric, 'object.avg') ||
                                     safeGet(metric, 'object.last_reading') ||
                                     safeGet(metric, 'object.value') || 'N/A';
                    groupedData[key].metrics['Temp_C'] = tempValue;
                } else {
                    // Handle other metric types
                    const metricName = metric.type || 'Unknown';
                    let value = safeGet(metric, 'object.value', 'N/A');
                    const unit = safeGet(metric, 'object.unit', '');
                    
                    // Create column name with unit
                    let columnName = metricName.replace(/[^a-zA-Z0-9]/g, '_'); // Replace non-alphanumeric with underscore
                    if (unit && unit !== '') {
                        columnName += `_${unit.toUpperCase()}`;
                    }
                    
                    groupedData[key].metrics[columnName] = value;
                }
            });
            
            // Collect all possible metric columns
            const allColumns = new Set(['User_Email', 'Date']);
            Object.values(groupedData).forEach(row => {
                Object.keys(row.metrics).forEach(col => allColumns.add(col));
            });
            
            // Convert to sorted array for consistent column order
            const sortedColumns = Array.from(allColumns).sort((a, b) => {
                // Keep User_Email and Date first
                if (a === 'User_Email') return -1;
                if (b === 'User_Email') return 1;
                if (a === 'Date') return -1;
                if (b === 'Date') return 1;
                
                // Sort sleep metrics first, then steps/temp, then others alphabetically
                const sleepMetrics = [
                    'Bedtime', 'Bedtime_Date', 'Bedtime_Unix',
                    'Wake_Time', 'Wake_Date', 'Wake_Unix',
                    'Time_In_Bed_HM', 'Time_In_Bed_Min',
                    'Total_Sleep_API_HM', 'Total_Sleep_API_Min',
                    'Total_Sleep_Derived_HM', 'Total_Sleep_Derived_Min',
                    'Sleep_Efficiency_Pct',
                    'Deep_Sleep_Min', 'Light_Sleep_Min', 'REM_Sleep_Min', 'Awake_Min',
                    'Sleep_Onset_Latency_Min', 'WASO_Min', 'Wake_Episodes',
                    'Sleep_HR_Avg_BPM', 'Sleep_HR_Min_BPM', 'Sleep_HR_Max_BPM',
                    'Sleep_HRV_Avg_MS', 'Sleep_HRV_Min_MS', 'Sleep_HRV_Max_MS',
                    'Steps_Daily', 'Temp_C'
                ];
                const aIsSleep = sleepMetrics.includes(a);
                const bIsSleep = sleepMetrics.includes(b);

                if (aIsSleep && !bIsSleep) return -1;
                if (!aIsSleep && bIsSleep) return 1;
                if (aIsSleep && bIsSleep) {
                    return sleepMetrics.indexOf(a) - sleepMetrics.indexOf(b);
                }

                return a.localeCompare(b);
            });
            
            // Create CSV content
            const csvRows = [];
            csvRows.push(sortedColumns.join(','));
            
            // Add data rows
            Object.values(groupedData).forEach(row => {
                const csvRow = sortedColumns.map(col => {
                    if (col === 'User_Email') return `"${row.userEmail}"`;
                    if (col === 'Date') return row.date;
                    return row.metrics[col] || 'N/A';
                });
                csvRows.push(csvRow.join(','));
            });
            
            // Create and download CSV
            const csvContent = csvRows.join("\n");
            const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
            const url = URL.createObjectURL(blob);
            
            const downloadLink = document.createElement("a");
            downloadLink.href = url;
            const dateStr = startDate === endDate ? startDate : `${startDate}_to_${endDate}`;
            downloadLink.download = `${filePrefix}_wide_format_${dateStr}.csv`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(url);
        }
        
        function exportMultiUserCSV(allUsersData, startDate, endDate) {
            const csvRows = [];
            const headers = ["User Email", "Date", "Metric Type", "Value", "Unit", "Details"];
            csvRows.push(headers.join(","));
            
            allUsersData.forEach(metric => {
                const userEmail = metric.userEmail || "N/A";
                const date = metric.date || "N/A";
                const type = metric.type || "N/A";
                
                // Handle sleep metrics by creating multiple CSV rows for each sleep component
                if (metric.type === "sleep" || metric.type === "Sleep") {
                    const hasFullSleepData = safeGet(metric, 'object.bedtime_start') && safeGet(metric, 'object.bedtime_end');

                    if (hasFullSleepData) {
                        const bedtimeStart = new Date(safeGet(metric, 'object.bedtime_start') * 1000);
                        const bedtimeEnd = new Date(safeGet(metric, 'object.bedtime_end') * 1000);
                        const timeInBedSeconds = safeGet(metric, 'object.bedtime_end') - safeGet(metric, 'object.bedtime_start');
                        const timeInBed = formatDuration(timeInBedSeconds);

                        // Get total sleep and efficiency from quick_metrics
                        const quickMetrics = safeGet(metric, 'object.quick_metrics');
                        const totalSleepMetric = getQuickMetric(quickMetrics, 'total_sleep');
                        const sleepEfficiencyMetric = getQuickMetric(quickMetrics, 'sleep_efic');
                        const totalSleep = totalSleepMetric ? formatDuration(totalSleepMetric.value) : null;
                        const sleepEfficiency = sleepEfficiencyMetric ? sleepEfficiencyMetric.value : null;

                        // Bedtime
                        csvRows.push([
                            `"${userEmail}"`,
                            date,
                            "Bedtime",
                            bedtimeStart.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }),
                            "Time",
                            "Sleep start time"
                        ].join(","));

                        // Wake Time
                        csvRows.push([
                            `"${userEmail}"`,
                            date,
                            "Wake Time",
                            bedtimeEnd.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }),
                            "Time",
                            "Sleep end time"
                        ].join(","));

                        // Bedtime Date
                        csvRows.push([
                            `"${userEmail}"`,
                            date,
                            "Bedtime Date",
                            bedtimeStart.toLocaleDateString('en-CA'),
                            "Date",
                            "Calendar date of bedtime"
                        ].join(","));

                        // Wake Date
                        csvRows.push([
                            `"${userEmail}"`,
                            date,
                            "Wake Date",
                            bedtimeEnd.toLocaleDateString('en-CA'),
                            "Date",
                            "Calendar date of wake time"
                        ].join(","));

                        // Bedtime Unix Timestamp
                        csvRows.push([
                            `"${userEmail}"`,
                            date,
                            "Bedtime Unix",
                            safeGet(metric, 'object.bedtime_start'),
                            "Unix",
                            "Unix timestamp of bedtime (seconds)"
                        ].join(","));

                        // Wake Unix Timestamp
                        csvRows.push([
                            `"${userEmail}"`,
                            date,
                            "Wake Unix",
                            safeGet(metric, 'object.bedtime_end'),
                            "Unix",
                            "Unix timestamp of wake time (seconds)"
                        ].join(","));

                        // Time in Bed (formatted)
                        csvRows.push([
                            `"${userEmail}"`,
                            date,
                            "Time in Bed",
                            timeInBed.formatted,
                            "hours/min",
                            "From bedtime to wake time"
                        ].join(","));

                        // Time in Bed (minutes)
                        csvRows.push([
                            `"${userEmail}"`,
                            date,
                            "Time in Bed (Minutes)",
                            timeInBed.totalMinutes,
                            "min",
                            "Time in bed in minutes"
                        ].join(","));

                        // Total Sleep - API value (if available)
                        if (totalSleep) {
                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "Total Sleep (API)",
                                totalSleep.formatted,
                                "hours/min",
                                "From API quick_metrics"
                            ].join(","));

                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "Total Sleep API (Minutes)",
                                totalSleep.totalMinutes,
                                "min",
                                "From API quick_metrics in minutes"
                            ].join(","));
                        }

                        // Sleep Efficiency (if available)
                        if (sleepEfficiency !== null) {
                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "Sleep Efficiency",
                                sleepEfficiency,
                                "%",
                                "Total sleep / Time in bed"
                            ].join(","));
                        }

                        // Sleep Heart Rate
                        if (safeGet(metric, 'object.hr_graph.gist_object.avg')) {
                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "Sleep Heart Rate",
                                safeGet(metric, 'object.hr_graph.gist_object.avg'),
                                "bpm",
                                `Min: ${safeGet(metric, 'object.hr_graph.gist_object.min', 'N/A')} bpm`
                            ].join(","));
                        }

                        // Sleep HRV
                        if (safeGet(metric, 'object.hrv_graph.gist_object.avg')) {
                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "Sleep HRV",
                                safeGet(metric, 'object.hrv_graph.gist_object.avg'),
                                "ms",
                                `Min: ${safeGet(metric, 'object.hrv_graph.gist_object.min', 'N/A')} ms, Max: ${safeGet(metric, 'object.hrv_graph.gist_object.max', 'N/A')} ms`
                            ].join(","));
                        }

                        // Derived sleep metrics from sleep_graph.data
                        const sleepGraphDataMulti = processSleepGraphData(safeGet(metric, 'object.sleep_graph.data'));
                        if (sleepGraphDataMulti.hasData) {
                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "Deep Sleep",
                                sleepGraphDataMulti.deepSleepMin,
                                "min",
                                "Deep sleep duration"
                            ].join(","));

                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "Light Sleep",
                                sleepGraphDataMulti.lightSleepMin,
                                "min",
                                "Light sleep duration"
                            ].join(","));

                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "REM Sleep",
                                sleepGraphDataMulti.remSleepMin,
                                "min",
                                "REM sleep duration"
                            ].join(","));

                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "Awake Time",
                                sleepGraphDataMulti.awakeMin,
                                "min",
                                "Total awake time during sleep period"
                            ].join(","));

                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "Sleep Onset Latency",
                                sleepGraphDataMulti.sleepOnsetLatencyMin,
                                "min",
                                "Time from bedtime to first sleep"
                            ].join(","));

                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "WASO",
                                sleepGraphDataMulti.wasoMin,
                                "min",
                                "Wake After Sleep Onset"
                            ].join(","));

                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "Wake Episodes",
                                sleepGraphDataMulti.wakeEpisodes,
                                "count",
                                "Number of awakenings during sleep"
                            ].join(","));

                            // Total Sleep (Derived) - Deep + Light + REM
                            const derivedHoursMulti = Math.floor(sleepGraphDataMulti.totalSleepDerivedMin / 60);
                            const derivedMinsMulti = sleepGraphDataMulti.totalSleepDerivedMin % 60;
                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "Total Sleep (Derived)",
                                `${derivedHoursMulti}h ${derivedMinsMulti}m`,
                                "hours/min",
                                "Deep + Light + REM from segments"
                            ].join(","));

                            csvRows.push([
                                `"${userEmail}"`,
                                date,
                                "Total Sleep Derived (Minutes)",
                                sleepGraphDataMulti.totalSleepDerivedMin,
                                "min",
                                "Deep + Light + REM from segments in minutes"
                            ].join(","));

                        }
                    }
                } else if (metric.type === "steps") {
                    // Handle steps with proper total value
                    const stepsTotal = safeGet(metric, 'object.total') || safeGet(metric, 'object.avg') || safeGet(metric, 'object.value') || "N/A";
                    csvRows.push([
                        `"${userEmail}"`,
                        date,
                        "Steps (Daily)",
                        stepsTotal,
                        "Steps",
                        "Daily total (calendar day)"
                    ].join(","));
                } else {
                    // Handle other metric types
                    let value = "N/A";
                    let unit = "";
                    let details = "";

                    if (metric.object) {
                        value = safeGet(metric, 'object.value', 'N/A');
                        unit = safeGet(metric, 'object.unit', '');
                        details = safeGet(metric, 'object.description', '');
                    }

                    csvRows.push([
                        `"${userEmail}"`,
                        date,
                        type,
                        value,
                        unit,
                        `"${details}"`
                    ].join(","));
                }
            });
            
            // Create and download CSV
            const csvContent = csvRows.join("\n");
            const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
            const url = URL.createObjectURL(blob);
            
            const downloadLink = document.createElement("a");
            downloadLink.href = url;
            downloadLink.download = `ultrahuman_multi_user_data_${startDate}_to_${endDate}.csv`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(url);
        }
        
        // --- Event Listeners ---
        showAddUserFormButton.addEventListener("click", () => showUserForm());
        cancelEditButton.addEventListener("click", hideUserForm);
        userForm.addEventListener("submit", saveUser);
        fetchDataButton.addEventListener("click", fetchMetrics);
        exportCsvButton.addEventListener("click", exportToCSV);
        singleDateMode.addEventListener("change", toggleDateMode);
        dateRangeMode.addEventListener("change", toggleDateMode);

        // --- Initial Load ---
        document.addEventListener("DOMContentLoaded", () => {
            fetchUsers();
            setDateToToday();
            toggleDateMode(); // Initialize date mode display
            
            // Multi-user export event listeners
            document.getElementById('select-all-users').addEventListener('change', function() {
                const checkboxes = document.querySelectorAll('#user-checkboxes input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = this.checked;
                });
            });
            
            document.getElementById('multi-export-button').addEventListener('click', async function() {
                const selectedUsers = [];
                const checkboxes = document.querySelectorAll('#user-checkboxes input[type="checkbox"]:checked');
                const startDate = document.getElementById('multi-start-date').value;
                const endDate = document.getElementById('multi-end-date').value;
                const loadingDiv = document.getElementById('multi-export-loading');
                const progressDiv = document.getElementById('multi-export-progress');
                const errorDiv = document.getElementById('multi-export-error');
                const successDiv = document.getElementById('multi-export-success');
                
                // Clear previous messages
                errorDiv.style.display = 'none';
                successDiv.style.display = 'none';
                
                // Validation
                if (checkboxes.length === 0) {
                    errorDiv.textContent = 'Please select at least one user.';
                    errorDiv.style.display = 'block';
                    return;
                }
                
                if (!startDate || !endDate) {
                    errorDiv.textContent = 'Please select both start and end dates.';
                    errorDiv.style.display = 'block';
                    return;
                }
                
                if (new Date(startDate) > new Date(endDate)) {
                    errorDiv.textContent = 'Start date must be before or equal to end date.';
                    errorDiv.style.display = 'block';
                    return;
                }
                
                const daysDiff = (new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24);
                if (daysDiff > 30) {
                    errorDiv.textContent = 'Date range cannot exceed 30 days.';
                    errorDiv.style.display = 'block';
                    return;
                }
                
                // Get selected user IDs
                checkboxes.forEach(checkbox => {
                    selectedUsers.push({
                        id: checkbox.value,
                        email: checkbox.nextElementSibling.textContent.split(' (ID:')[0]
                    });
                });
                
                // Show loading
                loadingDiv.style.display = 'block';
                this.disabled = true;
                
                try {
                    // Generate date range
                    const dateRange = [];
                    for (let d = new Date(startDate); d <= new Date(endDate); d.setDate(d.getDate() + 1)) {
                        dateRange.push(d.toISOString().split('T')[0]);
                    }
                    
                    // Collect data for all users
                    const allUsersData = [];
                    let totalRequests = selectedUsers.length * dateRange.length;
                    let completedRequests = 0;
                    
                    for (const user of selectedUsers) {
                        const userMetrics = [];
                        
                        for (const date of dateRange) {
                            completedRequests++;
                            progressDiv.textContent = `Processing ${user.email}: ${date} (${completedRequests}/${totalRequests})`;
                            
                            try {
                                const response = await fetch(`${metricsApiUrlBase}/${user.id}?date=${date}`);
                                const result = await response.json();
                                
                                if (response.ok && result.data && result.data.metric_data) {
                                    const dateMetrics = result.data.metric_data.map(metric => ({
                                        ...metric,
                                        date: date,
                                        userEmail: user.email
                                    }));
                                    userMetrics.push(...dateMetrics);
                                }
                            } catch (error) {
                                console.warn(`Failed to fetch data for ${user.email} on ${date}:`, error);
                            }
                        }
                        
                        allUsersData.push(...userMetrics);
                    }
                    
                    if (allUsersData.length === 0) {
                        throw new Error('No data found for the selected users and date range.');
                    }
                    
                    // Check selected format
                    const formatSelection = document.querySelector('input[name="multi-csv-format"]:checked');
                    const exportFormat = formatSelection ? formatSelection.value : 'long';
                    
                    // Export to CSV based on selected format
                    if (exportFormat === 'wide') {
                        exportWideFormatCSV(allUsersData, startDate, endDate, 'ultrahuman_multi_user_data');
                    } else {
                        exportMultiUserCSV(allUsersData, startDate, endDate);
                    }
                    
                    successDiv.textContent = `Successfully exported data for ${selectedUsers.length} user(s) from ${startDate} to ${endDate}.`;
                    successDiv.style.display = 'block';
                    
                } catch (error) {
                    console.error('Error during multi-user export:', error);
                    errorDiv.textContent = `Error: ${error.message}`;
                    errorDiv.style.display = 'block';
                } finally {
                    loadingDiv.style.display = 'none';
                    this.disabled = false;
                    progressDiv.textContent = 'Initializing...';
                }
            });
        });

        // --- Testing/Validation Functions (can be removed in production) ---
        function testCircularMean() {
            console.log('=== Testing Circular Mean Function ===');
            
            // Test Case 1: Normal bedtimes (no midnight crossing)
            const normalBedtimes = [22.5, 23.0, 22.75]; // 10:30 PM, 11:00 PM, 10:45 PM
            const normalAvg = calculateCircularMean(normalBedtimes, 'bedtime');
            console.log('Normal bedtimes:', normalBedtimes.map(t => formatTimeForDisplay(t, 'bedtime').displayTime));
            console.log('Average (should be ~10:55 PM):', formatTimeForDisplay(normalAvg, 'bedtime').displayTime);
            
            // Test Case 2: Bedtimes crossing midnight (the problem case)
            const midnightBedtimes = [23.5, 0.5, 23.0]; // 11:30 PM, 12:30 AM, 11:00 PM
            const midnightAvg = calculateCircularMean(midnightBedtimes, 'bedtime');
            console.log('\\nMidnight-crossing bedtimes:', midnightBedtimes.map(t => formatTimeForDisplay(t, 'bedtime').displayTime));
            console.log('Average (should be ~11:40 PM):', formatTimeForDisplay(midnightAvg, 'bedtime').displayTime);
            
            // Test Case 3: Wake times
            const wakeTimes = [7.0, 7.5, 6.75]; // 7:00 AM, 7:30 AM, 6:45 AM  
            const wakeAvg = calculateCircularMean(wakeTimes, 'waketime');
            console.log('\\nWake times:', wakeTimes.map(t => formatTimeForDisplay(t, 'waketime').displayTime));
            console.log('Average (should be ~7:05 AM):', formatTimeForDisplay(wakeAvg, 'waketime').displayTime);
            
            // Test Case 4: Edge case - very late bedtimes
            const veryLateBedtimes = [1.0, 2.0, 1.5]; // 1:00 AM, 2:00 AM, 1:30 AM
            const veryLateAvg = calculateCircularMean(veryLateBedtimes, 'bedtime');
            console.log('\\nVery late bedtimes:', veryLateBedtimes.map(t => formatTimeForDisplay(t, 'bedtime').displayTime));
            console.log('Average (should be ~1:30 AM):', formatTimeForDisplay(veryLateAvg, 'bedtime').displayTime);
            
            console.log('=== End Testing ===\\n');
        }
        
        // Test wide format export with sample data
        function testWideFormatExport() {
            console.log('=== Testing Wide Format Export ===');
            
            const sampleData = [
                {
                    userEmail: 'test@example.com',
                    date: '2024-01-15',
                    type: 'sleep',
                    object: {
                        bedtime_start: 1705357800, // 11:30 PM
                        bedtime_end: 1705386600,   // 7:30 AM
                        hr_graph: { gist_object: { avg: 65, min: 55, max: 75 } },
                        hrv_graph: { gist_object: { avg: 45, min: 35, max: 55 } }
                    }
                },
                {
                    userEmail: 'test@example.com',
                    date: '2024-01-15',
                    type: 'steps',
                    object: { value: 8500, unit: 'steps' }
                },
                {
                    userEmail: 'test@example.com', 
                    date: '2024-01-16',
                    type: 'sleep',
                    object: {
                        bedtime_start: 1705444200, // 11:30 PM next day
                        bedtime_end: 1705473000,   // 7:30 AM next day
                        hr_graph: { gist_object: { avg: 68, min: 58, max: 78 } }
                    }
                }
            ];
            
            console.log('Sample data prepared with', sampleData.length, 'metrics');
            console.log('This would create 2 rows (one per date) with columns for all metrics');
            console.log('Expected columns: User_Email, Date, Bedtime, Wake_Time, Sleep_Duration_Hours, Sleep_HR_Avg_BPM, Sleep_HR_Min_BPM, Sleep_HR_Max_BPM, Sleep_HRV_Avg_MS, Sleep_HRV_Min_MS, Sleep_HRV_Max_MS, STEPS_STEPS');
            
            // To actually test (uncomment next line):
            // exportWideFormatCSV(sampleData, '2024-01-15', '2024-01-16', 'test_wide_format');
        }
        
        // Uncomment the line below to run tests in browser console
        // testCircularMean();
        // testWideFormatExport();

    </script>
</body>
</html>

